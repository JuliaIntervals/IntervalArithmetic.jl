var documenterSearchIndex = {"docs":
[{"location":"intro/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"intro/","page":"Overview","title":"Overview","text":"The basic idea in interval arithmetic is to perform computations with a whole interval of real numbers","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"a b bydef x in mathbbR a le x le b ","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"where a b in mathbbR cup  pm infty ; note that despite the above notation, a b does not contain infinity when a or b are infinite.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"We define functions on intervals in such a way that the result of the computation is a new interval that is guaranteed to contain the true range of the function.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"For instance, by monotonicity, the exponential function is given by","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"e^a b bydef e^a e^b","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"On the other hand, the squaring function is non-monotone, thus it is given by the following cases","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"a b^2 bydef\nbegincases\na^2 b^2   0 le a le b \n0 max(a^2 b^2)  a le 0 le b \nb^2 a^2  a le b le 0\nendcases","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Of course, we must round the lower endpoint down and the upper endpoint up to get a guaranteed enclosure of the true result.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"IntervalArithmetic defines such behaviour for a wide set of basic functions, thereby allowing the evaluation of more complex functions such as","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"f(x) = sin(3x^2 - 2 cos(1x))","category":"page"},{"location":"intro/#Applications","page":"Overview","title":"Applications","text":"","category":"section"},{"location":"intro/","page":"Overview","title":"Overview","text":"To illustrate the use of interval arithmetic, consider the following:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"using IntervalArithmetic\nf(x) = x^2 - 2\nx = interval(3, 4)\nf(x)","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Since f(x) does not contain 0, the true range of the function f over the interval 3 4 is guaranteed not to contain 0, and hence we obtain the following property.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Theorem: f has no root in the interval 3 4.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"This theorem has been obtained using floating-point computations! In fact, we can even extend this to semi-infinite intervals:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"f(interval(3, Inf))","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Therefore, we have excluded the whole unbounded set 3 infty) from possibly containing roots of f.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Interval arithmetic is the foundation of more powerful and elaborate methods in the field of computer-assisted proofs (see e.g. IntervalRootFinding.jl).","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"The interested reader may refer to the following books:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"R. E. Moore, R. B. Kearfott and M. J. Cloud, Introduction to Interval Analysis, Society for Industrial and Applied Mathematics (2009)\nW. Tucker, Validated Numerics: A Short Introduction to Rigorous Computations, Princeton University Press (2010)","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"In this example, we compute rigorous bounds on pi using interval arithmetic[1], via the IntervalArithmetic.jl package.","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"[1]: W. Tucker, Validated Numerics: A Short Introduction to Rigorous Computations, Princeton University Press, 2011.","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"There are many ways to calculate pi. For illustrative purposes, we will use the following sum","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"S bydef sum_n=1^infty frac1n^2","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"According to the Basel Problem, the exact value is S = fracpi^26. Thus, if we can calculate a rigorous enclosure of S, then we can deduce a rigorous enclosure of pi.","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"First, we split S into a finite and infinite part, S = S_N + T_N, where","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"S_N bydef sum_n=1^N frac1n^2 qquad\nT_N bydef S - S_N = sum_n=N+1^infty frac1n^2","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"Using integrals from below and above, we obtain frac1N+1 le T_N le frac1N. It remains to compute rigorous bounds for S_N, which can be found by calculating the sum using interval arithmetic:","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"using IntervalArithmetic\n\nfunction forward_sum(N)\n    S_N = interval(0)\n\n    for i ∈ 1:N\n        S_N += interval(1) / interval(i) ^ interval(2)\n    end\n\n    T_N = interval(1) / interval(N, N+1)\n\n    S = S_N + T_N\n\n    return sqrt(interval(6) * S)\nend\n\npi_interval = forward_sum(10^6)\n\nmidradius(pi_interval)","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"The above computation shows that the midpoint of the computed interval is correct to about 10 decimal places. We can also verify directly that pi is indeed contained in the interval:","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"in_interval(π, pi_interval)","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"Lastly, let us note that, due to floating-point arithmetic, computing the sum in the opposite direction yields a more accurate answer:","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"function backward_sum(N)\n    S_N = interval(0)\n\n    for i ∈ N:-1:1\n        S_N += interval(1) / interval(i) ^ interval(2)\n    end\n\n    T_N = interval(1) / interval(N, N+1)\n\n    S = S_N + T_N\n\n    return sqrt(interval(6) * S)\nend\n\nimproved_pi_interval = backward_sum(10^6)\n\nmidradius(improved_pi_interval)","category":"page"},{"location":"manual/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"manual/api/","page":"API","title":"API","text":"CollapsedDocStrings = true","category":"page"},{"location":"manual/api/","page":"API","title":"API","text":"Modules = [IntervalArithmetic]\nPrivate = false","category":"page"},{"location":"manual/api/#IntervalArithmetic.BareInterval","page":"API","title":"IntervalArithmetic.BareInterval","text":"BareInterval{T<:NumTypes}\n\nInterval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015. Unlike Interval, this bare interval does not have decorations, is not a subtype of Real and errors on operations mixing BareInterval and Number.\n\nFields:\n\nlo :: T\nhi :: T\n\nConstructor compliant with the IEEE Standard 1788-2015: bareinterval.\n\nSee also: Interval.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.ExactReal","page":"API","title":"IntervalArithmetic.ExactReal","text":"ExactReal{T<:Real} <: Real\n\nReal numbers with the assurance that they precisely correspond to the number described by their binary form. The purpose is to guarantee that a non interval number is exact, so that ExactReal can be used with Interval without producing the \"NG\" flag.\n\ndanger: Danger\nBy using ExactReal, users acknowledge the responsibility of ensuring that the number they input corresponds to their intended value. For example, ExactReal(0.1) implies that the user knows that 01 can not be represented exactly as a binary number, and that they are using a slightly different number than 01. To help identify the binary number, ExactReal is displayed without any rounding.julia> ExactReal(0.1)\nExactReal{Float64}(0.1000000000000000055511151231257827021181583404541015625)In case of doubt, has_exact_display can be use to check if the string representation of a Real is equal to its binary value.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> 0.5 * interval(1)\nInterval{Float64}(0.5, 0.5, com, NG)\n\njulia> ExactReal(0.5) * interval(1)\nInterval{Float64}(0.5, 0.5, com)\n\njulia> [1, interval(2)]\n2-element Vector{Interval{Float64}}:\n Interval{Float64}(1.0, 1.0, com, NG)\n Interval{Float64}(2.0, 2.0, com)\n\njulia> [ExactReal(1), interval(2)]\n2-element Vector{Interval{Float64}}:\n Interval{Float64}(1.0, 1.0, com)\n Interval{Float64}(2.0, 2.0, com)\n\nSee also: @exact.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Interval","page":"API","title":"IntervalArithmetic.Interval","text":"Interval{T<:NumTypes} <: Real\n\nInterval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015. This structure combines a BareInterval together with a Decoration.\n\nFields:\n\nbareinterval :: BareInterval{T}\ndecoration   :: Decoration\nisguaranteed :: Bool\n\nConstructors compliant with the IEEE Standard 1788-2015:\n\ninterval\n..\n±\n@I_str\n\nSee also: ±, .. and @I_str.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.bareinterval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T","page":"API","title":"IntervalArithmetic.bareinterval","text":"bareinterval(T, a, b)\n\nCreate the bare interval a b according to the IEEE Standard 1788-2015. The validity of the interval is checked by is_valid_interval: if true then a BareInterval{T} is constructed, otherwise an empty interval is returned.\n\ndanger: Danger\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, parse the string containing the desired value to ensure its tight enclosure.\n\nSee also: interval, ±, .. and @I_str.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> bareinterval(1//1, π)\nBareInterval{Rational{Int64}}(1//1, 85563208//27235615)\n\njulia> bareinterval(Rational{Int32}, 1//1, π)\nBareInterval{Rational{Int32}}(1//1, 85563208//27235615)\n\njulia> bareinterval(1, π)\nBareInterval{Float64}(1.0, 3.1415926535897936)\n\njulia> bareinterval(BigFloat, 1, π)\nBareInterval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bisect-Union{Tuple{BareInterval{T}}, Tuple{T}, Tuple{BareInterval{T}, Real}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(x, α=0.5)\nbisect(x, i, α=0.5)\n\nSplit an interval x at a relative position α, where α = 0.5 corresponds to the midpoint.\n\nSplit the i-th component of a vector x at a relative position α, where α = 0.5 corresponds to the midpoint.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bounds-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.bounds","text":"bounds(x)\n\nBounds of x given as a tuple. Unlike inf, this function does not normalize the infimum of the interval.\n\nSee also: inf, sup, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.cancelminus","text":"cancelminus(x, y)\n\nCompute the unique interval z such that y + z == x.\n\nThe result is decorated by at most trv (Section 11.7.1).\n\nImplement the cancelMinus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.cancelplus-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.cancelplus","text":"cancelplus(x, y)\n\nCompute the unique interval z such that y - z == x; this is semantically equivalent to cancelminus(x, -y).\n\nThe result is decorated by at most trv (Section 11.7.1).\n\nImplement the cancelPlus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.diam-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.diam","text":"diam(x)\n\nDiameter of x. If x is complex, then the diameter is the maximum diameter between its real and imaginary parts.\n\nImplement the wid function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, mid, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.dist-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.dist","text":"dist(x, y)\n\nDistance between x and y.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.emptyinterval-Union{Tuple{Type{BareInterval{T}}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.emptyinterval","text":"emptyinterval(T=default_numtype())\n\nCreate an empty interval. This interval is an exception to the fact that the lower bound is larger than the upper one.\n\nImplement the empty function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.entireinterval-Union{Tuple{Type{BareInterval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.entireinterval","text":"entireinterval(T=default_numtype())\n\nCreate an interval representing the entire real line, or the entire complex plane if T is complex.\n\nnote: Note\nDepending on the flavor, infinity may or may not be considered part of the interval.\n\nImplement the entire function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.extended_div-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.extended_div","text":"extended_div(x, y)\n\nTwo-output division.\n\nImplement the mulRevToPair function of the IEEE Standard 1788-2015 (Section 10.5.5).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.fastpow-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.fastpow","text":"fastpow(x, y)\n\nA faster implementation of pow(x, y), at the cost of maybe returning a slightly larger interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.fastpown-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.fastpown","text":"fastpown(x, n)\n\nA faster implementation of pown(x, y), at the cost of maybe returning a slightly larger interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.has_exact_display-Tuple{Real}","page":"API","title":"IntervalArithmetic.has_exact_display","text":"has_exact_display(x::Real)\n\nDetermine if the display of x up to 2000 decimals is equal to the bitwise value of x. This is famously not true for the float displayed as 0.1.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.hull-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.hull","text":"hull(x, y)\n\nReturn the interval hull of the intervals x and y, considered as (extended) sets of real numbers, i.e. the smallest interval that contains all of x and y.\n\nThe result is decorated by at most trv (Section 11.7.1).\n\nImplement the convexHull function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.in_interval-Tuple{Number, BareInterval}","page":"API","title":"IntervalArithmetic.in_interval","text":"in_interval(x, y)\n\nTest whether x is an element of y.\n\nImplement the isMember function of the IEEE Standard 1788-2015 (Section 10.6.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.inf-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.inf","text":"inf(x)\n\nLower bound, or infimum, of x. For a zero AbstractFloat lower bound, a negative zero is returned.\n\nImplement the inf function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: sup, bounds, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.interiordiff-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.interiordiff","text":"interiordiff(x, y)\n\nRemove the interior of y from x. If x and y are vectors, then they are treated as multi-dimensional intervals.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.intersect_interval-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.intersect_interval","text":"intersect_interval(x, y)\n\nReturns the intersection of the intervals x and y, considered as (extended) sets of real numbers. That is, the set that contains the points common in x and y.\n\nThe result is decorated by at most trv (Section 11.7.1).\n\nImplement the intersection function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, IntervalArithmetic.Decoration}} where T","page":"API","title":"IntervalArithmetic.interval","text":"interval(T, a, b, d = com)\n\nCreate the interval a b according to the IEEE Standard 1788-2015. The validity of the interval is checked by is_valid_interval: if true then an Interval{T} is constructed, otherwise an NaI (Not an Interval) is returned.\n\ndanger: Danger\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, parse the string containing the desired value to ensure its tight enclosure.\n\nSee also: ±, .. and @I_str.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> interval(1//1, π)\nInterval{Rational{Int64}}(1//1, 85563208//27235615, com)\n\njulia> interval(Rational{Int32}, 1//1, π)\nInterval{Rational{Int32}}(1//1, 85563208//27235615, com)\n\njulia> interval(1, π)\nInterval{Float64}(1.0, 3.1415926535897936, com)\n\njulia> interval(BigFloat, 1, π)\nInterval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233, com)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isatomic-Tuple{BareInterval{<:AbstractFloat}}","page":"API","title":"IntervalArithmetic.isatomic","text":"isatomic(x)\n\nTest whether x is unable to be split. This occurs if the interval is empty, or if its lower and upper bounds are equal, or if the bounds are consecutive floating-point numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isbounded-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isbounded","text":"isbounded(x)\n\nTest whether x is empty or has finite bounds.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.iscommon-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.iscommon","text":"iscommon(x)\n\nTest whether x is not empty and bounded.\n\nnote: Note\nThis is does not take into consideration the decoration of the interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isdisjoint_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isdisjoint_interval","text":"isdisjoint_interval(x, y)\n\nTest whether x and y have no common elements.\n\nImplement the disjoint function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isempty_interval-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.isempty_interval","text":"isempty_interval(x)\n\nTest whether x contains no elements.\n\nImplement the isEmpty function of the IEEE Standard 1788-2015 (Section 10.6.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isentire_interval-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.isentire_interval","text":"isentire_interval(x)\n\nTest whether x is the entire real line.\n\nImplement the isEntire function of the IEEE Standard 1788-2015 (Section 10.6.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isequal_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isequal_interval","text":"isequal_interval(x, y)\n\nTest whether x and y are identical.\n\nImplement the equal function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isguaranteed-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isguaranteed","text":"isguaranteed(x::BareInterval)\nisguaranteed(x::Interval)\nisguaranteed(x::Complex{<:Interval})\n\nTest whether the interval is not guaranteed to encompass all possible numerical errors. This happens whenever an Interval is constructed using convert(::Type{<:Interval}, ::Real), which may occur implicitly when mixing intervals and Real types.\n\nSince conversion between BareInterval and Number is prohibited, this implies that isguaranteed(::BareInterval) == true.\n\nIn the case of a complex interval x, this is semantically equivalent to isguaranteed(real(x)) & isguaranteed(imag(x)).\n\nExamples\n\njulia> isguaranteed(bareinterval(1))\ntrue\n\njulia> isguaranteed(interval(1))\ntrue\n\njulia> isguaranteed(convert(Interval{Float64}, 1))\nfalse\n\njulia> isguaranteed(interval(1) + 0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isinterior-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isinterior","text":"isinterior(x, y)\n\nTest whether x is in the interior of y. If x and y are intervals, this is semantically equivalent to isstrictsubset(x, y).\n\nImplement the interior function of the IEEE Standard 1788-2015 (Table 9.3).\n\nSee also: isstrictsubset.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isnai-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isnai","text":"isnai(x)\n\nTest whether x is an NaI (Not an Interval).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isstrictless-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isstrictless","text":"isstrictless(x, y)\n\nTest whether inf(x) < inf(y) and sup(x) < sup(y), where < is replaced by ≤ for infinite values.\n\nImplement the strictLess function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isstrictsubset-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isstrictsubset","text":"isstrictsubset(x, y)\n\nTest whether x is a strict subset of y. If x and y are intervals, this is semantically equivalent to isinterior(x, y). If x and y are vectors, x must be a subset of y with at least one of their component being a strict subset.\n\nSee also: isinterior.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.issubset_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.issubset_interval","text":"issubset_interval(x, y)\n\nTest whether x is contained in y.\n\nImplement the subset function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthin-Tuple{BareInterval, Number}","page":"API","title":"IntervalArithmetic.isthin","text":"isthin(x, y)\n\nTest whether x contains only y.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthin-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthin","text":"isthin(x)\n\nTest whether x contains only a real.\n\nImplement the isSingleton function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthininteger-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthininteger","text":"isthininteger(x)\n\nTest whether x contains only an integer.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthinone-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthinone","text":"isthinone(x)\n\nTest whether x contains only one.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthinzero-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthinzero","text":"isthinzero(x)\n\nTest whether x contains only zero.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isunbounded-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isunbounded","text":"isunbounded(x)\n\nTest whether x is not empty and has infinite bounds.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isweakless-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isweakless","text":"isweakless(x, y)\n\nTest whether inf(x) ≤ inf(y) and sup(x) ≤ sup(y), where < is replaced by ≤ for infinite values.\n\nImplement the less function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mag-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.mag","text":"mag(x)\n\nMagnitude of x.\n\nImplement the mag function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: mig.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mid-Union{Tuple{BareInterval{T}}, Tuple{T}, Tuple{BareInterval{T}, Any}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.mid","text":"mid(x, α = 0.5)\n\nRelative midpoint of x, for α between 0 and 1 such that mid(x, 0) is the lower bound of the interval, mid(x, 1) its upper bound, and mid(x, 0.5) its midpoint.\n\nImplement the mid function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.midradius-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.midradius","text":"midradius(x)\n\nMidpoint and radius of x.\n\nFunction required by the IEEE Standard 1788-2015 in Section 10.5.9 for the set-based flavor.\n\nSee also: inf, sup, bounds, mid, mid and radius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mig-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mig","text":"mig(x)\n\nMignitude of x.\n\nImplement the mig function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: mag.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x, n)\n\nSplit an interval x in n intervals of the same diameter.\n\nSplit the i-th component of a vector x in n[i] intervals of the same diameter; n can be a tuple of integers, or a single integer in which case the same n is used for all the components of x.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.nai-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.nai","text":"nai(T=default_numtype())\n\nCreate an NaI (Not an Interval).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.overlap-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.overlap","text":"overlap(x::BareInterval, y::BareInterval)\noverlap(x::Interval, y::Interval)\n\nImplement the overlap function of the IEEE Standard 1788-2015 (Table 10.7).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.pow-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.pow","text":"pow(x, y)\n\nCompute the power of the positive real part of x by y. In particular, even if y is a thin integer, this is not equivalent to pown(x, sup(y)).\n\nImplement the pow function of the IEEE Standard 1788-2015 (Table 9.1).\n\nSee also: pown.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> pow(bareinterval(2, 3), bareinterval(2))\nBareInterval{Float64}(4.0, 9.0)\n\njulia> pow(interval(-1, 1), interval(3))\nInterval{Float64}(0.0, 1.0, trv)\n\njulia> pow(interval(-1, 1), interval(-3))\nInterval{Float64}(1.0, Inf, trv)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.pown-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.pown","text":"pown(x, n)\n\nImplement the pown function of the IEEE Standard 1788-2015 (Table 9.1).\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> pown(bareinterval(2, 3), 2)\nBareInterval{Float64}(4.0, 9.0)\n\njulia> pown(interval(-1, 1), 3)\nInterval{Float64}(-1.0, 1.0, com)\n\njulia> pown(interval(-1, 1), -3)\nInterval{Float64}(-Inf, Inf, trv)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.precedes-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.precedes","text":"precedes(x, y)\n\nTest whether any element of x is lesser or equal to every elements of y.\n\nImplement the precedes function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.radius-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.radius","text":"radius(x)\n\nRadius of x, such that issubset_interval(x, mid(x) ± radius(x)). If x is complex, then the radius is the maximum radius between its real and imaginary parts.\n\nImplement the rad function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, mid, diam and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.rootn-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.rootn","text":"rootn(x::BareInterval, n::Integer)\n\nCompute the real n-th root of x.\n\nImplement the rootn function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.setdisplay","page":"API","title":"IntervalArithmetic.setdisplay","text":"setdisplay(format::Symbol; decorations::Bool, ng_flag::Bool, sigdigits::Int)\n\nChange the format used by show to display intervals.\n\nPossible options:\n\nformat can be:\n:infsup: display intervals as [a, b].\n:midpoint: display intervals as m ± r.\n:full: display interval bounds entirely, ignoring sigdigits.\ndecorations: display the decorations or not.\nng_flag: display the NG flag or not.\nsigdigits: number (greater or equal to 1) of significant digits to display.\n\nInitially, the display options are set to setdisplay(:infsup; decorations = true, ng_flag = true, sigdigits = 6). If any of format, decorations, ng_flag and sigdigits is omitted, then their value is left unchanged.\n\nExamples\n\njulia> setdisplay(:infsup; decorations = true, sigdigits = 6) # default display options\nDisplay options:\n  - format: infsup\n  - decorations: true\n  - NG flag: true\n  - significant digits: 6\n\njulia> x = interval(0.1, 0.3)\n[0.0999999, 0.300001]_com\n\njulia> setdisplay(:full)\nDisplay options:\n  - format: full\n  - decorations: true\n  - NG flag: true\n  - significant digits: 6 (ignored)\n\njulia> x\nInterval{Float64}(0.1, 0.3, com)\n\njulia> setdisplay(:infsup; sigdigits = 3)\nDisplay options:\n  - format: infsup\n  - decorations: true\n  - NG flag: true\n  - significant digits: 3\n\njulia> x\n[0.0999, 0.301]_com\n\njulia> setdisplay(; decorations = false)\nDisplay options:\n  - format: infsup\n  - decorations: false\n  - NG flag: true\n  - significant digits: 3\n\njulia> x\n[0.0999, 0.301]\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.strictprecedes-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.strictprecedes","text":"strictprecedes(x, y)\n\nTest whether any element of x is strictly lesser than every elements of y.\n\nImplement the strictPrecedes function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.sup-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.sup","text":"sup(x)\n\nUpper bound, or supremum, of x.\n\nImplement the sup function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, bounds, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.@I_str-Tuple{Any}","page":"API","title":"IntervalArithmetic.@I_str","text":"I\"str\"\n\nCreate an interval by parsing the string \"str\"; this is semantically equivalent to parse(Interval{default_numtype()}, \"str\").\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> I\"[3, 4]\"\nInterval{Float64}(3.0, 4.0, com)\n\njulia> I\"0.1\"\nInterval{Float64}(0.09999999999999999, 0.1, com)\n\njulia> in_interval(1//10, I\"0.1\")\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.@exact-Tuple{Any}","page":"API","title":"IntervalArithmetic.@exact","text":"@exact\n\nWrap every literal numbers of the expression in an ExactReal. This macro allows defining generic functions, seamlessly accepting both Number and Interval arguments, without producing the \"NG\" flag.\n\ndanger: Danger\nBy using ExactReal, users acknowledge the responsibility of ensuring that the number they input corresponds to their intended value. For example, ExactReal(0.1) implies that the user knows that 01 can not be represented exactly as a binary number, and that they are using a slightly different number than 01. To help identify the binary number, ExactReal is displayed without any rounding.julia> ExactReal(0.1)\nExactReal{Float64}(0.1000000000000000055511151231257827021181583404541015625)In case of doubt, has_exact_display can be use to check if the string representation of a Real is equal to its binary value.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> f(x) = 1.2*x + 0.1\nf (generic function with 1 method)\n\njulia> f(interval(1, 2))\nInterval{Float64}(1.2999999999999998, 2.5, com, NG)\n\njulia> @exact g(x) = 1.2*x + 0.1\ng (generic function with 1 method)\n\njulia> g(interval(1, 2))\nInterval{Float64}(1.2999999999999998, 2.5, com)\n\njulia> g(1.4)\n1.78\n\nSee also: ExactReal.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.@interval-Tuple{Any}","page":"API","title":"IntervalArithmetic.@interval","text":"@interval(expr)\n@interval(T, expr)\n@interval(T, expr1, expr2)\n\nWalk through an expression and wrap each argument of functions with the internal constructor atomic.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> @macroexpand @interval sin(1) # Float64 is the default bound type\n:(sin(IntervalArithmetic.atomic(Float64, 1)))\n\njulia> @macroexpand @interval Float32 sin(1)\n:(sin(IntervalArithmetic.atomic(Float32, 1)))\n\njulia> @interval Float64 sin(1) exp(1)\nInterval{Float64}(0.8414709848078965, 2.7182818284590455, com)\n\n\n\n\n\n","category":"macro"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The library provides two interval types. The first one is BareInterval, corresponding to a basic implementation of intervals, stored by their infimum and supremum. The second type is Interval and builds on top of bare intervals, with the additional fields decoration and isguaranteed. See the sections below.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"using IntervalArithmetic\nsetdisplay(:full) # print the interval in full\nbareinterval(1, π) # `bareinterval(Float64, 1, π)`\ninterval(1, π) # `interval(Float64, 1, π)`, interval decorated with `com` (common)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Therefore, we strongly recommend the use of Interval over BareInterval to better track the effect of functions according to the IEEE Standard 1788-2015 specifications. For instance, taking the square root of an interval discards the negative part of the interval, without any notice for bare intervals:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"sqrt(bareinterval(-1, 1)) # `sqrt(bareinterval(0, 1))`\nsqrt(interval(-1, 1)) # interval decorated with `trv` (trivial)","category":"page"},{"location":"manual/construction/#Decorations","page":"Constructing intervals","title":"Decorations","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"A decoration is a label that indicates the status of a given interval. Decorated intervals provide valuable information on the result of evaluating a function on an initial interval.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Upon the application of a function f on an interval x, the resulting interval f(x) has either one of the following decorations:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"com (common): x is a closed, bounded, non-empty subset of the domain of f, f is continuous on the interval x, and f(x) is bounded.\ndac (defined and continuous): x is a non-empty subset of the domain of f, and f is continuous on x.\ndef (defined): x is a non-empty subset of the domain of f; in other words, f is defined at each point of x.\ntrv (trivial): f(x) carries no meaningful information.\nill (ill-formed): f(x) is Not an Interval (NaI).","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Each decoration is paired with an integer as follows: ill = 0, trv = 1, def = 2, dac = 3 and com = 4. Then, decorations degrade according to the propagation order com > dac > def > trv > ill.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"One can specify a decoration when constructing intervals. Otherwise, the interval is initialised with a decoration according to the underlying bare interval:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"com: non-empty and bounded.\ndac: unbounded.\ntrv: empty.\nill: NaI.","category":"page"},{"location":"manual/construction/#Examples","page":"Constructing intervals","title":"Examples","text":"","category":"section"},{"location":"manual/construction/#Common","page":"Constructing intervals","title":"Common","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(0.5, 3)\nsqrt(x)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Both input x and output sqrt(x) are common intervals since they are closed, bounded, non-empty and the square root is continuous over 12 3.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Observe that these decorations, together with the fact that any element of the interval sqrt(x) is also in the interval x, imply that the Schauder Fixed-Point Theorem is satisfied. More precisely, this computation proves the existence of a fixed-point of the square root in 12 3 (in this simple example, sqrt(1) = 1).","category":"page"},{"location":"manual/construction/#Defined-and-continuous","page":"Constructing intervals","title":"Defined and continuous","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(3, Inf)\nsqrt(x)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Both the intervals are unbounded, hence the maximum possible decoration is dac.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Note that overflows can also produce the decoration dac:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(floatmax(Float64))\nx + interval(1)","category":"page"},{"location":"manual/construction/#Defined-and-continuous-2","page":"Constructing intervals","title":"Defined and continuous","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(-3, 4)\nsign(x)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The sign function is discontinuous at 0, but is defined everywhere on the input interval, so the decoration of the result is def.","category":"page"},{"location":"manual/construction/#Trivial","page":"Constructing intervals","title":"Trivial","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(-3.5, 4)\nsqrt(x)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The negative part of x is discarded before evaluating the square root since its domain is 0 infty). The process of discarding parts of an interval that are not in the domain of a function is called loose evaluation. This event has been recorded by degrading the decoration of the resulting interval to trv, indicating that nothing is known about the relationship between x and sqrt(x).","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"In this case, we know why the decoration was reduced to trv. Generally, if this were just a single step in a longer calculation, a resulting decoration trv shows only that something like this occured at some step.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"For instance,","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"f = asin ∘ sqrt\nx = interval(-3, 3)\nf(x)\ny = interval(0, 3)\nf(y)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"In both cases, asin(sqrt(X)) gives a result with the decoration trv; to find out where things went wrong, the function must be analyzed.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"sqrt(x) # `f(x)` has the decoration is `trv` since `x` contains negative values\nsqrt(y) # the decoration is `com`\nasin(sqrt(y)) # `f(x)` has the decoration is `trv` since `sqrt(y)` contains values stricly greater than `1`","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"This shows that loose evaluation occurred in different parts of f for x and y.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"danger: Danger\nThe decoration trv is an indicator of information loss. Often this also reveals that something unexpected occured. Therefore, any interval marked by this decoration may not be trusted and the code may need to be revised.","category":"page"},{"location":"manual/construction/#Ill-formed","page":"Constructing intervals","title":"Ill-formed","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"interval(2, 1)\ninterval(NaN)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"These are all examples of ill-formed intervals, resulting in the decoration ill.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"danger: Danger\nThe decoration ill is an indicator that an error has occured. Therefore, any interval marked by this decoration cannot be trusted and the code needs to be debugged.","category":"page"},{"location":"manual/construction/#Guarantee","page":"Constructing intervals","title":"Guarantee","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"A guarantee is yet another label, independent of decorations, and not described by the IEEE Standard 1788-2015 specifications. Its purpose is to accomodate for Julia's extensive conversion and promotion system, while retaining reliability in computations. Specifically, an interval x constructed via interval satisfies isguaranteed(x) == true. However, if a call to convert(::Type{<:Interval}, ::Real) occurs, then the resulting interval x satisfies isguaranteed(x) == false, receiving the \"NG\" (not guaranteed) label. For instance, consider the following examples:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":" convert(Interval{Float64}, 1.) # considered \"not guaranteed\" as this call can be done implicitly","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"interval(1) # considered \"guaranteed\" as the user explicitly constructed the interval","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"In contrast, a BareInterval can only be constructed via bareinterval, it is not a subtype of Real, and there are no allowed conversion with Number. Thus, this interval type is always guaranteed.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"danger: Danger\nA user interested in validated numerics should always have a resulting interval for which isguaranteed is true.","category":"page"},{"location":"manual/construction/#More-constructors","page":"Constructing intervals","title":"More constructors","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The submodule IntervalArithmetic.Symbols exports the infix operator .. and ± as an alias for interval; this submodule must be explicitly imported.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"using IntervalArithmetic.Symbols\n0.1 .. 0.2 # interval(0.1, 0.2; format = :infsup)\n0.1 ± 0.2 # interval(0.1, 0.2; format = :midpoint)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Moreover, one can parse strings into intervals. The various string formats are the following:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"\"[m]\" is equivalent to interval(m, m).\n\"[l, r]\" is equivalent to interval(l, r).\n\"m?r\" is equivalent to interval(m-r, m+r).\n\"m?ren\" is equivalent to interval((m-r)*1en, (m+r)*1en).\n\"m?rd\" is equivalent to interval(m-r, m).\n\"m?ru\" is equivalent to interval(m, m+r).\n\"m?\" is equivalent to interval(m + 5 precision units, m - 5 precision units).\n\"m??\" is equivalent to interval(-Inf, +Inf).\n\"m??d\" is equivalent to interval(-Inf, m).\n\"m??u\" is equivalent to interval(m, +Inf).\n\"[Entire]\", \"[entire]\" and \"[,]\" are equivalent to entireinterval().\n\"[Empty]\", \"[empty]\" and \"[]\" are equivalent to emptyinterval().\n\"[nai]\" and any other unsupported string formats are equivalent to nai().","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"To add a specific decoration, add \"_com\", \"_dac\", \"_dec\", \"_trv\" and \"_ill\" at the end of the string.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"danger: Danger\nMost real numbers cannot be exactly represented by floating-points. In such cases, the literal expression is rounded at parse time. To construct an interval enclosing the true real number, one must rely on the string constructor mentioned above.For instance, considerx = 0.1This appears to store the real number 110  in a variable x of type Float64. Yet,x > 1//10Hence, the floating-point 0.1 is (slightly) greater than the real number 110 since 110 cannot be represented exactly in binary floating-point arithmetic, at any precision. The true value must be approximated by a floating-point number with fixed precision – this procedure is called rounding.In particular, this implies that interval(0.1) does not contain the real number 110. A valid interval containing the real number 110 can be constructed byI\"0.1\"","category":"page"},{"location":"manual/usage/#Display-modes","page":"Usage","title":"Display modes","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"There are several useful output representations for intervals. The display is controlled globally by the setdisplay function, which has the following options:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"interval output format:\n:infsup: output of the form [1.09999, 1.30001], rounded to the current number of significant figures.\n:full: output of the form Interval(1.0999999999999999, 1.3), as in the showfull function.\n:midpoint: output in the midpoint-radius form, e.g. 1.2 ± 0.100001.\nsigfigs :: Int keyword argument: number of significant figures to show in standard mode.\ndecorations :: Bool keyword argument: whether to show decorations or not.","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"using IntervalArithmetic\na = interval(1.1, pi) # default display\nsetdisplay(; sigdigits = 10)\na\nsetdisplay(:full)\na\nsetdisplay(:midpoint)\na\nsetdisplay(; sigdigits = 4)\na\nsetdisplay(:infsup)\na","category":"page"},{"location":"manual/usage/#Arithmetic-operations","page":"Usage","title":"Arithmetic operations","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Basic arithmetic operations (+, -, *, /, ^) are defined for pairs of intervals in a standard way: the result is the smallest interval containing the result of operating with each element of each interval. More precisely, for two intervals X and Y and an operation bigcirc, we define the operation on the two intervals by","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X bigcirc Y bydef  x bigcirc y  x in X text and  y in Y ","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"For example,","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"using IntervalArithmetic\nsetdisplay(:full)\nX = interval(0, 1)\nY = interval(1, 2)\nX + Y","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Due to the above definition, subtraction of two intervals may give poor enclosures:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X - X","category":"page"},{"location":"manual/usage/#Elementary-functions","page":"Usage","title":"Elementary functions","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"The main elementary functions are implemented. The functions for Interval{Float64} internally use routines from the correctly-rounded CRlibm library where possible, i.e. for the following functions defined in that library:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"exp, expm1\nlog, log1p, log2, log10\nsin, cos, tan\nasin, acos, atan\nsinh, cosh","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Other functions that are implemented for Interval{Float64} internally convert to an Interval{BigFloat}, and then use routines from the MPFR library (BigFloat in Julia):","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"^\nexp2, exp10\natan, atanh","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"In particular, in order to obtain correct rounding for the power function (^), intervals are converted to and from BigFloat; this implies a significant slow-down in this case.","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"For example,","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X = interval(1)\nsin(X)\ncos(cosh(X))\nsetprecision(BigFloat, 53)\nY = big(X)\nsin(Y)\ncos(cosh(Y))\nsetprecision(BigFloat, 128)\nsin(Y)","category":"page"},{"location":"manual/usage/#Comparisons-and-set-operations","page":"Usage","title":"Comparisons and set operations","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"All comparisons and set operations for Real have been purposely disallowed to prevent silent errors.","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"interval(1) < interval(2)\nprecedes(interval(1), interval(2))\nissubset(interval(1, 2), interval(2))\nissubset_interval(interval(1, 2), interval(2))\nintersect(interval(1, 2), interval(2))\nintersect_interval(interval(1, 2), interval(2))","category":"page"},{"location":"manual/usage/#Custom-interval-bounds-type","page":"Usage","title":"Custom interval bounds type","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"A BareInterval{T} or Interval{T} have the restriction T <: Union{Rational,AbstractFloat} which is the parametric type for the bounds of the interval. Supposing one wishes to use their own numeric type MyNumType <: Union{Rational,AbstractFloat}, they must provide their own arithmetic operations (with correct rounding!).","category":"page"},{"location":"#IntervalArithmetic.jl","page":"Home","title":"IntervalArithmetic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntervalArithmetic.jl is a Julia package for validated numerics in Julia. All calculations are carried out using interval arithmetic where quantities are treated as intervals. The final result is a rigorous enclosure of the true value.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg # Julia v1.9 or above\nredirect_stderr(devnull) do # hide\nPkg.add(\"IntervalArithmetic\")\nend # hide","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use the IntervalArithmetic library in your publication, research, teaching, or other activities, please use the BibTeX template CITATION.bib.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MPFI.jl, a Julia wrapper around the MPFI C library, a multiple-precision interval arithmetic library based on MPFR\nIntervals.jl, an alternative implementation of basic interval functions by Invenia Technical Computing","category":"page"}]
}
