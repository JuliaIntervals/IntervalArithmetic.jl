var documenterSearchIndex = {"docs":
[{"location":"intro/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"intro/","page":"Overview","title":"Overview","text":"The basic idea in interval arithmetic is to perform computations with a whole interval of real numbers","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"a b bydef x in mathbbR a le x le b ","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"where a b in mathbbR cup  pm infty ; note that despite the above notation, a b does not contain infinity when a or b are infinite.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"We define functions on intervals in such a way that the result of the computation is a new interval that is guaranteed to contain the true range of the function.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"For instance, by monotonicity, the exponential function is given by","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"e^a b bydef e^a e^b","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"On the other hand, the squaring function is non-monotone, thus it is given by the following cases","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"a b^2 bydef\nbegincases\na^2 b^2   0 le a le b \n0 max(a^2 b^2)  a le 0 le b \nb^2 a^2  a le b le 0\nendcases","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Of course, we must round the lower endpoint down and the upper endpoint up to get a guaranteed enclosure of the true result.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"IntervalArithmetic defines such behaviour for a wide set of basic functions, thereby allowing the evaluation of more complex functions such as","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"f(x) = sin(3x^2 - 2 cos(1x))","category":"page"},{"location":"intro/#Applications","page":"Overview","title":"Applications","text":"","category":"section"},{"location":"intro/","page":"Overview","title":"Overview","text":"To illustrate the use of interval arithmetic, consider the following:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"using IntervalArithmetic\nf(x) = x^2 - 2\nx = interval(3, 4)\nf(x)","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Since f(x) does not contain 0, the true range of the function f over the interval 3 4 is guaranteed not to contain 0, and hence we obtain the following property.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Theorem: f has no root in the interval 3 4.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"This theorem has been obtained using floating-point computations! In fact, we can even extend this to semi-infinite intervals:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"f(interval(3, Inf))","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Therefore, we have excluded the whole unbounded set 3 infty) from possibly containing roots of f.","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"Interval arithmetic is the foundation of more powerful and elaborate methods in the field of computer-assisted proofs (see e.g. IntervalRootFinding.jl).","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"The interested reader may refer to the following books:","category":"page"},{"location":"intro/","page":"Overview","title":"Overview","text":"R. E. Moore, R. B. Kearfott and M. J. Cloud, Introduction to Interval Analysis, Society for Industrial and Applied Mathematics (2009)\nW. Tucker, Validated Numerics: A Short Introduction to Rigorous Computations, Princeton University Press (2010)","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"In this example, we compute rigorous bounds on pi using interval arithmetic[1], via the IntervalArithmetic.jl package.","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"[1]: W. Tucker, Validated Numerics: A Short Introduction to Rigorous Computations, Princeton University Press, 2011.","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"There are many ways to calculate pi. For illustrative purposes, we will use the following sum","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"S bydef sum_n=1^infty frac1n^2","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"According to the Basel Problem, the exact value is S = fracpi^26. Thus, if we can calculate a rigorous enclosure of S, then we can deduce a rigorous enclosure of pi.","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"First, we split S into a finite and infinite part, S = S_N + T_N, where","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"S_N bydef sum_n=1^N frac1n^2 qquad\nT_N bydef S - S_N = sum_n=N+1^infty frac1n^2","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"Using integrals from below and above, we obtain frac1N+1 le T_N le frac1N. It remains to compute rigorous bounds for S_N, which can be found by calculating the sum using interval arithmetic:","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"using IntervalArithmetic\n\nfunction forward_sum(N)\n    S_N = interval(0)\n\n    for i ∈ 1:N\n        S_N += interval(1) / interval(i) ^ interval(2)\n    end\n\n    T_N = interval(1) / interval(N, N+1)\n\n    S = S_N + T_N\n\n    return sqrt(interval(6) * S)\nend\n\npi_interval = forward_sum(10^6)\n\nmidradius(pi_interval)","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"The above computation shows that the midpoint of the computed interval is correct to about 10 decimal places. We can also verify directly that pi is indeed contained in the interval:","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"in_interval(π, pi_interval)","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"Lastly, let us note that, due to floating-point arithmetic, computing the sum in the opposite direction yields a more accurate answer:","category":"page"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"function backward_sum(N)\n    S_N = interval(0)\n\n    for i ∈ N:-1:1\n        S_N += interval(1) / interval(i) ^ interval(2)\n    end\n\n    T_N = interval(1) / interval(N, N+1)\n\n    S = S_N + T_N\n\n    return sqrt(interval(6) * S)\nend\n\nimproved_pi_interval = backward_sum(10^6)\n\nmidradius(improved_pi_interval)","category":"page"},{"location":"manual/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"manual/api/","page":"API","title":"API","text":"Modules = [IntervalArithmetic]\nOrder   = [:type, :function, :macro, :constant]","category":"page"},{"location":"manual/api/#IntervalArithmetic.BareInterval","page":"API","title":"IntervalArithmetic.BareInterval","text":"BareInterval{T<:NumTypes}\n\nInterval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015. Unlike Interval, this bare interval does not have decorations, is not a subtype of Real and errors on operations mixing BareInterval and Number.\n\nFields:\n\nlo :: T\nhi :: T\n\nConstructor compliant with the IEEE Standard 1788-2015: bareinterval.\n\nSee also: Interval.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Decoration","page":"API","title":"IntervalArithmetic.Decoration","text":"Decoration\n\nEnumeration constant for the types of interval decorations described in Section 11.2 of the IEEE Standard 1788-2015:\n\ncom -> 4 (common): non-empty, continuous and bounded interval.\ndac -> 3 (defined and continuous): non-empty and continuous interval.\ndef -> 2 (defined): non-empty interval.\ntrv -> 1 (trivial): meaningless interval.\nill -> 0 (ill-formed): not an interval (NaI).\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Flavor","page":"API","title":"IntervalArithmetic.Flavor","text":"Flavor{F}\n\nA flavor defining how an interval behaves in edge cases. For instance, infinity may or not be considered part of unbounded intervals.\n\nSome flavors F include:\n\n:set_based (default): elements of an interval are real numbers. In   particular, infinity is never part of an interval. This flavor is described   and required in Part 2 of the IEEE Standard 1788-2015.   Edge cases:       - any unbounded interval does not contain infinity.       - 0 0  0 0 = emptyset.       - x  0 0 = emptyset for any interval x.       - x times 0 0 = 0 0 for any interval x.\n:cset: elements of an interval are either real numbers,   or pm infty, applying standard rule for arithmetic with infinity.   Edge cases:       - any unbounded interval contains infinity.       - 0 0  0 0 = -infty infty.       - x  0 0 = -infty infty for any interval x.       - x times 0 0 = -infty infty for any unbounded interval         x.\n\nnote: Note\nCurrently only the flavor :set_based is supported and implemented.\n\nExamples\n\njulia> IntervalArithmetic.default_flavor()\nIntervalArithmetic.Flavor{:set_based}()\n\njulia> isempty_interval(bareinterval(Inf, Inf))\n┌ Warning: invalid interval, empty interval is returned\n└ @ IntervalArithmetic ~/work/IntervalArithmetic.jl/IntervalArithmetic.jl/src/intervals/construction.jl:202\ntrue\n\njulia> isempty_interval(bareinterval(0)/bareinterval(0))\ntrue\n\njulia> isempty_interval(bareinterval(1)/bareinterval(0))\ntrue\n\njulia> isempty_interval(bareinterval(-Inf, Inf)/bareinterval(0))\ntrue\n\njulia> isthinzero(bareinterval(0)*bareinterval(-Inf, Inf))\ntrue\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Interval","page":"API","title":"IntervalArithmetic.Interval","text":"Interval{T<:NumTypes} <: Real\n\nInterval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015. This structure combines a BareInterval together with a Decoration.\n\nFields:\n\nbareinterval :: BareInterval{T}\ndecoration   :: Decoration\nisguaranteed :: Bool\n\nConstructors compliant with the IEEE Standard 1788-2015:\n\ninterval\n..\n±\n@I_str\n\nSee also: ±, .. and @I_str.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.IntervalRounding","page":"API","title":"IntervalArithmetic.IntervalRounding","text":"IntervalRounding\n\nInterval rounding type.\n\nAvailable rounding types:\n\n:fast (unsupported): rounding via prevfloat and nextfloat.\n:tight: rounding via RoundingEmulator.jl.\n:slow: rounding via setrounding.\n:none: no rounding (non-rigorous numerics).\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.PowerMode","page":"API","title":"IntervalArithmetic.PowerMode","text":"PowerMode\n\nPower mode type for ^.\n\nAvailable mode types:\n\n:fast (default): x ^ y is semantically equivalent to fastpow(x, y),\n\nunless isthininteger(y) is true in which case it is semantically equivalent to fastpown(x, sup(y)).\n\n:slow: x ^ y is semantically equivalent to pow(x, y), unless\n\nisthininteger(y) is true in which case it is semantically equivalent to pown(x, sup(y)).\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#Base.:*-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:*","text":"*(x::BareInterval, y::BareInterval)\n*(x::Interval, y::Interval)\n\nImplement the mul function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of * is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:+-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:+","text":"+(x::BareInterval, y::BareInterval)\n+(x::Interval, y::Interval)\n\nImplement the add function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:--Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:-","text":"-(x::BareInterval)\n-(x::Interval)\n\nImplement the neg function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:--Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:-","text":"-(x::BareInterval, y::BareInterval)\n-(x::Interval, y::Interval)\n\nImplement the sub function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:/-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.:/","text":"/(x::BareInterval, y::BareInterval)\n/(x::Interval, y::Interval)\n\nImplement the div function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of / is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:==-Tuple{BareInterval, Number}","page":"API","title":"Base.:==","text":"==(::BareInterval, ::Number)\n==(::Number, ::BareInterval)\n==(::Interval, ::Number)\n==(::Number, ::Interval)\n\nTest whether an interval is the singleton of a given number. In other words, the result is true if and only if the interval contains only that number. This function errors whenever the input interval is not a singleton.\n\nnote: Note\nComparison between intervals is purposely disallowed. Indeed, equality between non-singleton intervals has distinct properties, notably x = y does not imply x - y = 0. See instead isequal_interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.:^-Tuple{BareInterval, BareInterval}","page":"API","title":"Base.:^","text":"^(x::BareInterval, y::BareInterval)\n^(x::Interval, y::Interval)\n\nCompute the power of the positive real part of x by y. This function is not in the IEEE Standard 1788-2015. Its behaviour depend on the current PowerMode.\n\nSee also: pow and pown.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> bareinterval(2, 3) ^ bareinterval(2)\nBareInterval{Float64}(4.0, 9.0)\n\njulia> interval(-1, 1) ^ interval(3)\nInterval{Float64}(-1.0, 1.0, com)\n\njulia> interval(-1, 1) ^ interval(-3)\nInterval{Float64}(-Inf, Inf, trv)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.acot-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.acot","text":"acot(::BareInterval)\nacot(::Interval)\n\nImplement the acot function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.acoth-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.acoth","text":"acoth(::BareInterval)\nacoth(::Interval)\n\nImplement the acoth function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.cot-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.cot","text":"cot(::BareInterval)\ncot(::Interval)\n\nImplement the cot function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.coth-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.coth","text":"coth(::BareInterval)\ncoth(::Interval)\n\nImplement the coth function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.csc-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.csc","text":"csc(::BareInterval)\ncsc(::Interval)\n\nImplement the csc function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.csch-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.csch","text":"csch(::BareInterval)\ncsch(::Interval)\n\nImplement the csch function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.hypot-Tuple{BareInterval, BareInterval}","page":"API","title":"Base.Math.hypot","text":"hypot(x, y)\n\nCompute the hypotenuse.\n\nImplement the hypot function of the IEEE Standard 1788-2015 (Table 10.5).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.sec-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.sec","text":"sec(::BareInterval)\nsec(::Interval)\n\nImplement the sec function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.Math.sech-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.Math.sech","text":"sech(::BareInterval)\nsech(::Interval)\n\nImplement the sech function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.abs-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.abs","text":"abs(x::BareInterval)\nabs(x::Interval)\n\nImplement the abs function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.abs2-Tuple{BareInterval}","page":"API","title":"Base.abs2","text":"abs2(x::BareInterval)\nabs2(x::Interval)\n\nImplement the square absolute value.\n\nnote: Note\nThis function calls ^ internally, hence it depends on IntervalArithmetic.power_mode().\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.acos-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.acos","text":"acos(::BareInterval)\nacos(::Interval)\n\nImplement the acos function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.acosh-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.acosh","text":"acosh(::BareInterval)\nacosh(::Interval)\n\nImplement the acosh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.asin-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.asin","text":"asin(::BareInterval)\nasin(::Interval)\n\nImplement the asin function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.asinh-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.asinh","text":"asinh(::BareInterval)\nasinh(::Interval)\n\nImplement the asinh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.atan-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.atan","text":"atan(::BareInterval)\natan(::Interval)\n\nImplement the atan function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.atan-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.atan","text":"atan(::BareInterval, ::BareInterval)\natan(::Interval, ::Interval)\n\nImplement the atan2 function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.atanh-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.atanh","text":"atanh(::BareInterval)\natanh(::Interval)\n\nImplement the atanh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.ceil-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.ceil","text":"ceil(x::BareInterval)\nceil(x::Interval)\n\nImplement the ceil function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.cos-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.cos","text":"cos(::BareInterval)\ncos(::Interval)\n\nImplement the cos function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.cosh-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.cosh","text":"cosh(::BareInterval)\ncosh(::Interval)\n\nImplement the cosh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.floor-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.floor","text":"floor(x::BareInterval)\nfloor(x::Interval)\n\nImplement the floor function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.fma-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.fma","text":"fma(x::BareInterval, y::BareInterval, z::BareInterval)\nfma(x::Interval, y::Interval, z::Interval)\n\nImplement the fma function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.hash-Tuple{BareInterval, UInt64}","page":"API","title":"Base.hash","text":"hash(x::BareInterval, h::UInt)\nhash(x::Interval, h::UInt)\n\nCompute the integer hash code for an interval. Note that equality of intervals is given by isequal_interval rather than the == operator.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.inv-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.inv","text":"inv(x::BareInterval)\ninv(x::Interval)\n\nImplement the recip function of the IEEE Standard 1788-2015 (Table 9.1).\n\nnote: Note\nThe behavior of inv is flavor dependent for some edge cases.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.isinteger-Tuple{BareInterval}","page":"API","title":"Base.isinteger","text":"isinteger(::BareInterval)\nisinteger(::Interval)\n\nTest whether an interval is the singleton of an integer. This function errors whenever the input interval is not a singleton.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.isone-Tuple{BareInterval}","page":"API","title":"Base.isone","text":"isone(::BareInterval)\nisone(::Interval)\n\nTest whether an interval is the singleton of one. This function errors whenever the input interval is not a singleton.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.iszero-Tuple{BareInterval}","page":"API","title":"Base.iszero","text":"iszero(::BareInterval)\niszero(::Interval)\n\nTest whether an interval is the singleton of zero. This function errors whenever the input interval is not a singleton.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.max-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.max","text":"max(x::BareInterval, y::BareInterval)\nmax(x::Interval, y::Interval)\n\nImplement the max function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.min-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.min","text":"min(x::BareInterval, y::BareInterval)\nmin(x::Interval, y::Interval)\n\nImplement the min function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.muladd-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.muladd","text":"muladd(x::BareInterval, y::BareInterval z::BareInterval)\nmuladd(x::Interval, y::Interval z::Interval)\n\nImplement the combined multiply-add; this is semantically equivalent to x * y + z.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.parse-Union{Tuple{T}, Tuple{Type{BareInterval{T}}, AbstractString}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.parse","text":"parse(T<:BareInterval, str)\nparse(T<:Interval, str)\n\nCreate an interval according to the IEEE Standard 1788-2015. In contrast with constructors that do not use strings, this constructor guarantees that the returned interval tightly encloses the values described by the string, including numbers that have no exact float representation (e.g. 0.1).\n\nParse a string of the form \"[a, b]_dec\" as an Interval with decoration dec. If the decoration is not specified, it is computed based on the parsed interval. If the input is an invalid string, a warning is printed and NaI is returned. The parser is case unsensitive.\n\nExamples of allowed string formats:\n\nI\"[1.33]\" or I\"1.33\": the interval containing 133.\nI\"[1.44, 2.78]\": the interval 144 278.\nI\"[empty]\": the empty interval.\nI\"[entire]\" or I\"[,]\": the interval -infty infty.\nI\"[3,]\": the interval 3 infty.\nI\"6.42?2\": the interval 64  644. The number after ? represents the   uncertainty in the last digit; by default this value is 0.5. The direction   of the uncertainty can be given by adding u or d at the end for the error   to only go up or down respectively (e.g. I\"4.5?5u\" represents 45 5).\nI\"6.42?2e2\": the interval 642 644.\nI\"3??u\": the interval 3 infty.\nI\"3??u\": the interval 3 infty.\nI\"3??\": the interval -infty infty.\n\nFor more details, see sections 9.7 and 12.11 of the IEEE Standard 1788-2015.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> parse(BareInterval{Float64}, \"[1, 2]\")\nBareInterval{Float64}(1.0, 2.0)\n\njulia> parse(BareInterval{Float64}, \"[1,]\")\nBareInterval{Float64}(1.0, Inf)\n\njulia> parse(BareInterval{Float64}, \"[,]\")\nBareInterval{Float64}(-Inf, Inf)\n\njulia> parse(BareInterval{Float64}, \"6.42?2e2\")\nBareInterval{Float64}(640.0, 644.0)\n\njulia> parse(Interval{Float64}, \"[1, 2]\")\nInterval{Float64}(1.0, 2.0, com)\n\njulia> parse(Interval{Float64}, \"[1, 2]_def\")\nInterval{Float64}(1.0, 2.0, def)\n\njulia> parse(Interval{Float64}, \"[1, 1e400]_com\")\nInterval{Float64}(1.0, Inf, dac)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.round-Tuple{Union{BareInterval, Interval}}","page":"API","title":"Base.round","text":"round(x::BareInterval, [RoundingMode])\nround(x::Interval, [RoundingMode])\n\nReturn an interval with the bounds of x rounded to an integer.\n\nImplement the functions roundTiesToEven and roundTiesToAway of the IEEE Standard 1788-2015.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.sign-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sign","text":"sign(x::BareInterval)\nsign(x::Interval)\n\nImplement the sign function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.sin-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sin","text":"sin(::BareInterval)\nsin(::Interval)\n\nImplement the sin function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.sinh-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sinh","text":"sinh(::BareInterval)\nsinh(::Interval)\n\nImplement the sinh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.sqrt-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.sqrt","text":"sqrt(x::BareInterval)\nsqrt(x::Interval)\n\nImplement the sqrt function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.tan-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.tan","text":"tan(::BareInterval)\ntan(::Interval)\n\nImplement the tan function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.tanh-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.tanh","text":"tanh(::BareInterval)\ntanh(::Interval)\n\nImplement the tanh function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#Base.trunc-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"Base.trunc","text":"trunc(x::BareInterval)\ntrunc(x::Interval)\n\nImplement the trunc function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic._bigequiv-Tuple{T} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic._bigequiv","text":"_bigequiv(x)\n\nCreate a BigFloat with the same underlying precision.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic._interval_infsup-Union{Tuple{T}, Tuple{Type{T}, Any, Any, IntervalArithmetic.Decoration}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic._interval_infsup","text":"_interval_infsup(T<:NumTypes, a, b, [d::Decoration])\n\nInternal constructor for intervals described by their lower and upper bounds, i.e. of the form a b.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic._interval_midpoint-Union{Tuple{T}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, IntervalArithmetic.Decoration}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic._interval_midpoint","text":"_interval_midpoint(T<:NumTypes, m, r, d = com)\n\nInternal constructor for intervals described by their midpoint and radius, i.e. of the form m pm r.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic._round_expr-Tuple{Expr, RoundingMode}","page":"API","title":"IntervalArithmetic._round_expr","text":"_round_expr(ex::Expr, rounding_mode::RoundingMode)\n\nTransforms a single expression by applying a rounding mode, e.g.\n\na + b into +(a, b, RoundDown)\nsin(a) into sin(a, RoundDown)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic._unsafe_bareinterval","page":"API","title":"IntervalArithmetic._unsafe_bareinterval","text":"_unsafe_bareinterval(T<:NumTypes, lo, hi)\n\nInternal constructor which assumes that is_valid_interval(lo, hi) == true.\n\ndanger: Danger\nThis constructor is not compliant with the IEEE Standard 1788-2015. Since misuse of this function can deeply corrupt code, its usage is strongly discouraged in favour of bareinterval.\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic._unsafe_interval","page":"API","title":"IntervalArithmetic._unsafe_interval","text":"_unsafe_interval(bareinterval::BareInterval, decoration::Decoration, isguaranteed::Bool)\n\nInternal constructor which assumes that bareinterval and its decoration decoration are compliant with the IEEE Standard 1788-2015.\n\ndanger: Danger\nThis constructor is not compliant with the IEEE Standard 1788-2015. Since misuse of this function can deeply corrupt code, its usage is strongly discouraged in favour of interval.\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.atomic-Union{Tuple{T}, Tuple{Type{T}, AbstractString}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.atomic","text":"atomic(T<:Union{Rational,AbstractFloat}, x)\n\nCreate an interval according to the IEEE Standard 1788-2015. The returned Interval{T} always contains the value x; this is semantically equivalent to parse(Interval{T}, string(x)) if x is a Number.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> x = IntervalArithmetic.atomic(Float64, 0.1)\nInterval{Float64}(0.09999999999999999, 0.1, com)\n\njulia> in_interval(1//10, IntervalArithmetic.atomic(Float64, 0.1))\ntrue\n\njulia> IntervalArithmetic.atomic(Float64, 0.3)\nInterval{Float64}(0.3, 0.30000000000000004, com)\n\njulia> in_interval(3//10, IntervalArithmetic.atomic(Float64, 0.3))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bareinterval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.bareinterval","text":"bareinterval([T<:Union{Rational,AbstractFloat}=default_numtype()], a, b)\n\nCreate the bare interval a b according to the IEEE Standard 1788-2015. The validity of the interval is checked by is_valid_interval: if true then a BareInterval{T} is constructed, otherwise an empty interval is returned.\n\ndanger: Danger\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, parse the string containing the desired value to ensure its tight enclosure.\n\nSee also: interval, ±, .. and @I_str.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> bareinterval(1//1, π)\nBareInterval{Rational{Int64}}(1//1, 85563208//27235615)\n\njulia> bareinterval(Rational{Int32}, 1//1, π)\nBareInterval{Rational{Int32}}(1//1, 85563208//27235615)\n\njulia> bareinterval(1, π)\nBareInterval{Float64}(1.0, 3.1415926535897936)\n\njulia> bareinterval(BigFloat, 1, π)\nBareInterval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bisect-Union{Tuple{BareInterval{T}}, Tuple{T}, Tuple{BareInterval{T}, Real}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(x, α=0.5)\nbisect(x, i, α=0.5)\n\nSplit an interval x at a relative position α, where α = 0.5 corresponds to the midpoint.\n\nSplit the i-th component of a vector x at a relative position α, where α = 0.5 corresponds to the midpoint.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bounds-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.bounds","text":"bounds(x)\n\nBounds of x given as a tuple. Unlike inf, this function does not normalize the infimum of the interval.\n\nSee also: inf, sup, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.cancelminus","text":"cancelminus(x, y)\n\nCompute the unique interval z such that y + z == x.\n\nThe result is decorated by at most trv (Section 11.7.1).\n\nImplement the cancelMinus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.cancelplus-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.cancelplus","text":"cancelplus(x, y)\n\nCompute the unique interval z such that y - z == x; this is semantically equivalent to cancelminus(x, -y).\n\nThe result is decorated by at most trv (Section 11.7.1).\n\nImplement the cancelPlus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.contains_infinity-Tuple{IntervalArithmetic.Flavor{:set_based}, BareInterval}","page":"API","title":"IntervalArithmetic.contains_infinity","text":"contains_infinity([F::Flavor=default_flavor()], x::BareInterval)\n\nFor the given flavor F, test whether x contains infinity.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.default_flavor-Tuple{}","page":"API","title":"IntervalArithmetic.default_flavor","text":"default_flavor()\n\nReturn the default flavor used to handle edge cases.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.default_numtype-Tuple{}","page":"API","title":"IntervalArithmetic.default_numtype","text":"default_numtype()\n\nReturn the default bound type used in promote_numtype. By default, default_numtype() is set to Float64. It can be modified by redefining the function, however it should be set to a concrete subtype of NumTypes.\n\nExamples\n\njulia> IntervalArithmetic.default_numtype() = Float32\n\njulia> typeof(interval(1, 2))\nInterval{Float32}\n\njulia> typeof(interval(1, big(2)))\nInterval{BigFloat}\n\njulia> IntervalArithmetic.default_numtype() = Float64\n\njulia> typeof(interval(1, 2))\nInterval{Float64}\n\njulia> typeof(interval(1, big(2)))\nInterval{BigFloat}\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.diam-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.diam","text":"diam(x)\n\nDiameter of x. If x is complex, then the diameter is the maximum diameter between its real and imaginary parts.\n\nImplement the wid function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, mid, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.dist-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.dist","text":"dist(x, y)\n\nDistance between x and y.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.div_by_thin_zero-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.div_by_thin_zero","text":"div_by_thin_zero([F::Flavor=default_flavor()], x::BareInterval)\n\nFor the given flavor F, divide x by the interval containing only 0.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.emptyinterval-Union{Tuple{Type{BareInterval{T}}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.emptyinterval","text":"emptyinterval(T=default_numtype())\n\nCreate an empty interval. This interval is an exception to the fact that the lower bound is larger than the upper one.\n\nImplement the empty function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.entireinterval-Union{Tuple{Type{BareInterval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.entireinterval","text":"entireinterval(T=default_numtype())\n\nCreate an interval representing the entire real line, or the entire complex plane if T is complex.\n\nnote: Note\nDepending on the flavor, infinity may or may not be considered part of the interval.\n\nImplement the entire function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.extended_div-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.extended_div","text":"extended_div(x, y)\n\nTwo-output division.\n\nImplement the mulRevToPair function of the IEEE Standard 1788-2015 (Section 10.5.5).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.fastpow-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.fastpow","text":"fastpow(x, y)\n\nA faster implementation of pow(x, y), at the cost of maybe returning a slightly larger interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.fastpown-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.fastpown","text":"fastpown(x, n)\n\nA faster implementation of pown(x, y), at the cost of maybe returning a slightly larger interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.hull-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.hull","text":"hull(x, y)\n\nReturn the interval hull of the intervals x and y, considered as (extended) sets of real numbers, i.e. the smallest interval that contains all of x and y.\n\nThe result is decorated by at most trv (Section 11.7.1).\n\nImplement the convexHull function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.in_interval-Tuple{Number, BareInterval}","page":"API","title":"IntervalArithmetic.in_interval","text":"in_interval(x, y)\n\nTest whether x is an element of y.\n\nImplement the isMember function of the IEEE Standard 1788-2015 (Section 10.6.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.inf-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.inf","text":"inf(x)\n\nLower bound, or infimum, of x. For a zero AbstractFloat lower bound, a negative zero is returned.\n\nImplement the inf function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: sup, bounds, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.interiordiff!-Union{Tuple{T}, Tuple{AbstractVector, BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.interiordiff!","text":"interiordiff(x, y)\n\nIn-place version of interiordiff.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.interiordiff-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.interiordiff","text":"interiordiff(x, y)\n\nRemove the interior of y from x. If x and y are vectors, then they are treated as multi-dimensional intervals.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.intersect_interval-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.intersect_interval","text":"intersect_interval(x, y)\n\nReturns the intersection of the intervals x and y, considered as (extended) sets of real numbers. That is, the set that contains the points common in x and y.\n\nThe result is decorated by at most trv (Section 11.7.1).\n\nImplement the intersection function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, IntervalArithmetic.Decoration}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.interval","text":"interval([T<:Union{Rational,AbstractFloat}=default_numtype()], a, b, d = com)\n\nCreate the interval a b according to the IEEE Standard 1788-2015. The validity of the interval is checked by is_valid_interval: if true then an Interval{T} is constructed, otherwise an NaI (Not an Interval) is returned.\n\ndanger: Danger\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, parse the string containing the desired value to ensure its tight enclosure.\n\nSee also: ±, .. and @I_str.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> interval(1//1, π)\nInterval{Rational{Int64}}(1//1, 85563208//27235615, com)\n\njulia> interval(Rational{Int32}, 1//1, π)\nInterval{Rational{Int32}}(1//1, 85563208//27235615, com)\n\njulia> interval(1, π)\nInterval{Float64}(1.0, 3.1415926535897936, com)\n\njulia> interval(BigFloat, 1, π)\nInterval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233, com)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.is_valid_interval-Tuple{IntervalArithmetic.Flavor{:set_based}, Real, Real}","page":"API","title":"IntervalArithmetic.is_valid_interval","text":"is_valid_interval([F::Flavor=default_flavor()], a::Real, b::Real)\n\nFor the given flavor F, test whether a b is a valid interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isatomic-Tuple{BareInterval{<:AbstractFloat}}","page":"API","title":"IntervalArithmetic.isatomic","text":"isatomic(x)\n\nTest whether x is unable to be split. This occurs if the interval is empty, or if its lower and upper bounds are equal, or if the bounds are consecutive floating-point numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isbounded-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isbounded","text":"isbounded(x)\n\nTest whether x is empty or has finite bounds.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.iscommon-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.iscommon","text":"iscommon(x)\n\nTest whether x is not empty and bounded.\n\nnote: Note\nThis is does not take into consideration the decoration of the interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isdisjoint_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isdisjoint_interval","text":"isdisjoint_interval(x, y)\n\nTest whether x and y have no common elements.\n\nImplement the disjoint function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isempty_interval-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.isempty_interval","text":"isempty_interval(x)\n\nTest whether x contains no elements.\n\nImplement the isEmpty function of the IEEE Standard 1788-2015 (Section 10.6.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isentire_interval-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.isentire_interval","text":"isentire_interval(x)\n\nTest whether x is the entire real line.\n\nImplement the isEntire function of the IEEE Standard 1788-2015 (Section 10.6.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isequal_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isequal_interval","text":"isequal_interval(x, y)\n\nTest whether x and y are identical.\n\nImplement the equal function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isguaranteed-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isguaranteed","text":"isguaranteed(x::BareInterval)\nisguaranteed(x::Interval)\nisguaranteed(x::Complex{<:Interval})\n\nTest whether the interval is not guaranteed to encompass all possible numerical errors. This happens whenever an Interval is constructed using convert(::Type{<:Interval}, ::Real), which may occur implicitly when mixing intervals and Real types.\n\nSince conversion between BareInterval and Number is prohibited, this implies that isguaranteed(::BareInterval) == true.\n\nIn the case of a complex interval x, this is semantically equivalent to isguaranteed(real(x)) & isguaranteed(imag(x)).\n\nExamples\n\njulia> isguaranteed(bareinterval(1))\ntrue\n\njulia> isguaranteed(interval(1))\ntrue\n\njulia> isguaranteed(convert(Interval{Float64}, 1))\nfalse\n\njulia> isguaranteed(interval(1) + 0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isinterior-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isinterior","text":"isinterior(x, y)\n\nTest whether x is in the interior of y.\n\nImplement the interior function of the IEEE Standard 1788-2015 (Table 9.3).\n\nSee also: isstrictsubset.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isnai-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isnai","text":"isnai(x)\n\nTest whether x is an NaI (Not an Interval).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isstrictless-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isstrictless","text":"isstrictless(x, y)\n\nTest whether inf(x) < inf(y) and sup(x) < sup(y), where < is replaced by ≤ for infinite values.\n\nImplement the strictLess function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isstrictsubset-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isstrictsubset","text":"isstrictsubset(x, y)\n\nTest whether x is a strict subset of y. If x and y are intervals, this is semantically equivalent to isinterior(x, y). If x and y are vectors, at least one component of x must be in the interior of y.\n\nSee also: isinterior.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.issubset_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.issubset_interval","text":"issubset_interval(x, y)\n\nTest whether x is contained in y.\n\nImplement the subset function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthin-Tuple{BareInterval, Number}","page":"API","title":"IntervalArithmetic.isthin","text":"isthin(x, y)\n\nTest whether x contains only y.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthin-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthin","text":"isthin(x)\n\nTest whether x contains only a real.\n\nImplement the isSingleton function of the IEEE Standard 1788-2015 (Table 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthininteger-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthininteger","text":"isthininteger(x)\n\nTest whether x contains only an integer.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthinone-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthinone","text":"isthinone(x)\n\nTest whether x contains only one.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthinzero-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthinzero","text":"isthinzero(x)\n\nTest whether x contains only zero.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isunbounded-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isunbounded","text":"isunbounded(x)\n\nTest whether x is not empty and has infinite bounds.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isweakless-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isweakless","text":"isweakless(x, y)\n\nTest whether inf(x) ≤ inf(y) and sup(x) ≤ sup(y), where < is replaced by ≤ for infinite values.\n\nImplement the less function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mag-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.mag","text":"mag(x)\n\nMagnitude of x.\n\nImplement the mag function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: mig.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mid-Union{Tuple{BareInterval{T}}, Tuple{T}, Tuple{BareInterval{T}, Any}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.mid","text":"mid(x)\n\nMidpoint of x.\n\nImplement the mid function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, diam, radius and midradius.\n\nmid(x, α)\n\nRelative midpoint of x, for α between 0 and 1.\n\nmid(x, 0) is the lower bound of the interval, mid(x, 1) the upper bound, and mid(x, 0.5) the midpoint.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.midradius-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.midradius","text":"midradius(x)\n\nMidpoint and radius of x.\n\nFunction required by the IEEE Standard 1788-2015 in Section 10.5.9 for the set-based flavor.\n\nSee also: inf, sup, bounds, mid, mid and radius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mig-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mig","text":"mig(x)\n\nMignitude of x.\n\nImplement the mig function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: mag.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince!-Union{Tuple{T}, Tuple{AbstractVector{<:BareInterval}, BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mince!","text":"mince!(v, x, n)\n\nIn-place version of mince.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x, n)\n\nSplit an interval x in n intervals of the same diameter.\n\nSplit the i-th component of a vector x in n[i] intervals of the same diameter; n can be a tuple of integers, or a single integer in which case the same n is used for all the components of x.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.nai-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.nai","text":"nai(T=default_numtype())\n\nCreate an NaI (Not an Interval).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.numtype-Union{Tuple{Type{BareInterval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.numtype","text":"numtype(T)\n\nReturn the bounds type of the interval.\n\nExamples\n\njulia> IntervalArithmetic.numtype(interval(1, 2))\nFloat64\n\njulia> IntervalArithmetic.numtype(interval(Float32, 1, 2))\nFloat32\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.overlap-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.overlap","text":"overlap(x::BareInterval, y::BareInterval)\noverlap(x::Interval, y::Interval)\n\nImplement the overlap function of the IEEE Standard 1788-2015 (Table 10.7).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.pow-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.pow","text":"pow(x, y)\n\nCompute the power of the positive real part of x by y. In particular, even if y is a thin integer, this is not equivalent to pown(x, sup(y)).\n\nImplement the pow function of the IEEE Standard 1788-2015 (Table 9.1).\n\nSee also: pown.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> pow(bareinterval(2, 3), bareinterval(2))\nBareInterval{Float64}(4.0, 9.0)\n\njulia> pow(interval(-1, 1), interval(3))\nInterval{Float64}(0.0, 1.0, trv)\n\njulia> pow(interval(-1, 1), interval(-3))\nInterval{Float64}(1.0, Inf, trv)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.pown-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.pown","text":"pown(x, n)\n\nImplement the pown function of the IEEE Standard 1788-2015 (Table 9.1).\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> pown(bareinterval(2, 3), 2)\nBareInterval{Float64}(4.0, 9.0)\n\njulia> pown(interval(-1, 1), 3)\nInterval{Float64}(-1.0, 1.0, com)\n\njulia> pown(interval(-1, 1), -3)\nInterval{Float64}(-Inf, Inf, trv)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.precedes-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.precedes","text":"precedes(x, y)\n\nTest whether any element of x is lesser or equal to every elements of y.\n\nImplement the precedes function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.promote_numtype-Union{Tuple{S}, Tuple{T}, Tuple{Type{T}, Type{S}}} where {T<:Union{AbstractFloat, Rational}, S<:Union{AbstractFloat, Rational}}","page":"API","title":"IntervalArithmetic.promote_numtype","text":"promote_numtype(T, S)\n\nReturn the bound type used to construct intervals. The bound type is given by promote_type(T, S) if T or S is a Rational or an AbstractFloat; except when T is a Rational{R} and S is an AbstractIrrational (or vice-versa), in which case the bound type is given by Rational{promote_type(R, Int64)}. In all other cases, the bound type is given by promote_type(default_numtype(), T, S).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.radius-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.radius","text":"radius(x)\n\nRadius of x, such that issubset_interval(x, mid(x) ± radius(x)). If x is complex, then the radius is the maximum radius between its real and imaginary parts.\n\nImplement the rad function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, mid, diam and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.rootn-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.rootn","text":"rootn(x::BareInterval, n::Integer)\n\nCompute the real n-th root of x.\n\nImplement the rootn function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.setdisplay","page":"API","title":"IntervalArithmetic.setdisplay","text":"setdisplay(format::Symbol; decorations::Bool, sigdigits::Int)\n\nChange the format used by show to display intervals.\n\nPossible options:\n\nformat can be:\n:infsup: display intervals as [a, b].\n:midpoint: display intervals as m ± r.\n:full: display interval bounds entirely, ignoring sigdigits.\ndecorations: display the decorations or not.\nsigdigits: number (greater or equal to 1) of significant digits to display.\n\nInitially, the display options are set to setdisplay(:infsup; decorations = false, sigdigits = 6). If any of the three argument format, decorations and sigdigits is omitted, then their value is left unchanged.\n\nExamples\n\njulia> setdisplay(:infsup; decorations = true, sigdigits = 6) # default display options\nDisplay options:\n  - format: infsup\n  - decorations: true\n  - significant digits: 6\n\njulia> x = interval(0.1, 0.3)\n[0.0999999, 0.300001]_com\n\njulia> setdisplay(:full)\nDisplay options:\n  - format: full\n  - decorations: true\n  - significant digits: 6 (ignored)\n\njulia> x\nInterval{Float64}(0.1, 0.3, com)\n\njulia> setdisplay(:infsup; sigdigits = 3)\nDisplay options:\n  - format: infsup\n  - decorations: true\n  - significant digits: 3\n\njulia> x\n[0.0999, 0.301]_com\n\njulia> setdisplay(; decorations = false)\nDisplay options:\n  - format: infsup\n  - decorations: false\n  - significant digits: 3\n\njulia> x\n[0.0999, 0.301]\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.strictprecedes-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.strictprecedes","text":"strictprecedes(x, y)\n\nTest whether any element of x is strictly lesser than every elements of y.\n\nImplement the strictPrecedes function of the IEEE Standard 1788-2015 (Table 10.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.sup-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.sup","text":"sup(x)\n\nUpper bound, or supremum, of x.\n\nImplement the sup function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, bounds, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.zero_times_infinity-Union{Tuple{T}, Tuple{IntervalArithmetic.Flavor{:set_based}, Type{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.zero_times_infinity","text":"zero_times_infinity([F::Flavor=default_flavor()], T<:NumTypes)\n\nFor the given flavor F, return 0 times infty as an instance of type T.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.@I_str-Tuple{Any}","page":"API","title":"IntervalArithmetic.@I_str","text":"I\"str\"\n\nCreate an interval by parsing the string \"str\"; this is semantically equivalent to parse(Interval{default_numtype()}, \"str\").\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> I\"[3, 4]\"\nInterval{Float64}(3.0, 4.0, com)\n\njulia> I\"0.1\"\nInterval{Float64}(0.09999999999999999, 0.1, com)\n\njulia> in_interval(1//10, I\"0.1\")\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.@interval-Tuple{Any, Any}","page":"API","title":"IntervalArithmetic.@interval","text":"@interval(T, expr)\n@interval(T, expr1, expr2)\n\nWalk through an expression and wrap each argument of functions with the internal constructor atomic.\n\nExamples\n\njulia> setdisplay(:full);\n\njulia> @macroexpand @interval Float64 sin(1)\n:(sin(IntervalArithmetic.atomic(Float64, 1)))\n\njulia> @interval Float64 sin(1) exp(1)\nInterval{Float64}(0.8414709848078965, 2.7182818284590455, com)\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.@round-Tuple{Any, Any, Any}","page":"API","title":"IntervalArithmetic.@round","text":"@round(T, ex1, ex2)\n\nMacro for internal use that creates an interval by rounding down ex1 and rounding up ex2. Each expression may consist of only a single operation that needs rounding, e.g. a.lo + b.lo or sin(a.lo). It also handles min(...) and max(...), where the arguments are each themselves single operations.\n\nThe macro uses the internal _round_expr function to transform e.g. a + b into +(a, b, RoundDown).\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.NumTypes","page":"API","title":"IntervalArithmetic.NumTypes","text":"NumTypes\n\nConstant for the supported types of interval bounds. This is set to Union{Rational,AbstractFloat}.\n\n\n\n\n\n","category":"type"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The library provides two interval types. The first one is BareInterval, corresponding to a basic implementation of intervals, stored by their infimum and supremum. The second type is Interval and builds on top of bare intervals, with the additional fields decoration and isguaranteed. See the sections below.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"using IntervalArithmetic\nsetdisplay(:full) # print the interval in full\nbareinterval(1, π) # `bareinterval(Float64, 1, π)`\ninterval(1, π) # `interval(Float64, 1, π)`, interval decorated with `com` (common)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Therefore, we strongly recommend the use of Interval over BareInterval to better track the effect of functions according to the IEEE Standard 1788-2015 specifications. For instance, taking the square root of an interval discards the negative part of the interval, without any notice for bare intervals:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"sqrt(bareinterval(-1, 1)) # `sqrt(bareinterval(0, 1))`\nsqrt(interval(-1, 1)) # interval decorated with `trv` (trivial)","category":"page"},{"location":"manual/construction/#Decorations","page":"Constructing intervals","title":"Decorations","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"A decoration is a label that indicates the status of a given interval. Decorated intervals provide valuable information on the result of evaluating a function on an initial interval.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Upon the application of a function f on an interval x, the resulting interval f(x) has either one of the following decorations:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"com (common): x is a closed, bounded, non-empty subset of the domain of f, f is continuous on the interval x, and f(x) is bounded.\ndac (defined and continuous): x is a non-empty subset of the domain of f, and f is continuous on x.\ndef (defined): x is a non-empty subset of the domain of f; in other words, f is defined at each point of x.\ntrv (trivial): f(x) carries no meaningful information.\nill (ill-formed): f(x) is Not an Interval (NaI).","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Each decoration is paired with an integer as follows: ill = 0, trv = 1, def = 2, dac = 3 and com = 4. Then, decorations degrade according to the propagation order com > dac > def > trv > ill.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"One can specify a decoration when constructing intervals. Otherwise, the interval is initialised with a decoration according to the underlying bare interval:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"com: non-empty and bounded.\ndac: unbounded.\ntrv: empty.\nill: NaI.","category":"page"},{"location":"manual/construction/#Examples","page":"Constructing intervals","title":"Examples","text":"","category":"section"},{"location":"manual/construction/#Common","page":"Constructing intervals","title":"Common","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(0.5, 3)\nsqrt(x)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Both input x and output sqrt(x) are common intervals since they are closed, bounded, non-empty and that sqrt is continuous over 12 3.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Observe that these decorations, together with the fact that any element of the interval sqrt(x) is also in the interval x, imply that the Schauder Fixed-Point Theorem is satisfied. More precisely, this computation proves the existence of a fixed-point of sqrt in 12 3 (in this simple example, sqrt(1) = 1).","category":"page"},{"location":"manual/construction/#Defined-and-continuous","page":"Constructing intervals","title":"Defined and continuous","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(3, Inf)\nsqrt(x)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Both the intervals are unbounded, hence the maximum possible decoration is dac.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Note that overflows can also produce the decoration dac:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(floatmax(Float64))\nx + interval(1)","category":"page"},{"location":"manual/construction/#Defined-and-continuous-2","page":"Constructing intervals","title":"Defined and continuous","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(-3, 4)\nsign(x)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The sign function is discontinuous at 0, but is defined everywhere on the input interval, so the decoration of the result is def.","category":"page"},{"location":"manual/construction/#Trivial","page":"Constructing intervals","title":"Trivial","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"x = interval(-3.5, 4)\nsqrt(x)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The negative part of x is discarded before evaluating the sqrt function since its domain is 0 infty). The process of discarding parts of an interval that are not in the domain of a function is called loose evaluation. This event has been recorded by degrading the decoration of the resulting interval to trv, indicating that nothing is known about the relationship between x and sqrt(x).","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"In this case, we know why the decoration was reduced to trv. Generally, if this were just a single step in a longer calculation, a resulting decoration trv shows only that something like this occured at some step.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"For instance,","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"f = asin ∘ sqrt\nx = interval(-3, 3)\nf(x)\ny = interval(0, 3)\nf(y)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"In both cases, asin(sqrt(X)) gives a result with the decoration trv; to find out where things went wrong, the function must be analyzed.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"sqrt(x) # `f(x)` has the decoration is `trv` since `x` contains negative values\nsqrt(y) # the decoration is `com`\nasin(sqrt(y)) # `f(x)` has the decoration is `trv` since `sqrt(y)` contains values stricly greater than `1`","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"This shows that loose evaluation occurred in different parts of f for x and y.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"danger: Danger\nThe decoration trv is an indicator of information loss. Often this also reveals that something unexpected occured. Therefore, any interval marked by this decoration may not be trusted and the code may need to be revised.","category":"page"},{"location":"manual/construction/#Ill-formed","page":"Constructing intervals","title":"Ill-formed","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"interval(2, 1)\ninterval(NaN)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"These are all examples of ill-formed intervals, resulting in the decoration ill.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"danger: Danger\nThe decoration ill is an indicator that an error has occured. Therefore, any interval marked by this decoration cannot be trusted and the code needs to be debugged.","category":"page"},{"location":"manual/construction/#Guarantee","page":"Constructing intervals","title":"Guarantee","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"A guarantee is yet another label, independent of decorations, and not described by the IEEE Standard 1788-2015 specifications. Its purpose is to accomodate for Julia's extensive conversion and promotion system, while retaining reliability in computations. Specifically, an interval x constructed via interval satisfies isguaranteed(x) == true. However, if a call to convert(::Type{<:Interval}, ::Real) occurs, then the resulting interval x satisfies isguaranteed(x) == false.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"In contrast, a BareInterval can only be constructed via bareinterval, it is not a subtype of Real, and there are no allowed conversion with Number. Thus, this interval type is always guaranteed.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"danger: Danger\nA user interested in validated numerics should always have a resulting interval for which isguaranteed is true.","category":"page"},{"location":"manual/construction/#More-constructors","page":"Constructing intervals","title":"More constructors","text":"","category":"section"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"The submodule IntervalArithmetic.Symbols exports the infix operator .. and ± as an alias for interval; this submodule must be explicitly imported.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"using IntervalArithmetic.Symbols\n0.1 .. 0.2 # interval(0.1, 0.2; format = :infsup)\n0.1 ± 0.2 # interval(0.1, 0.2; format = :midpoint)","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"Moreover, one can parse strings into intervals. The various string formats are the following:","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"\"[m]\" is equivalent to interval(m, m).\n\"[l, r]\" is equivalent to interval(l, r).\n\"m?r\" is equivalent to interval(m-r, m+r).\n\"m?ren\" is equivalent to interval((m-r)*1en, (m+r)*1en).\n\"m?rd\" is equivalent to interval(m-r, m).\n\"m?ru\" is equivalent to interval(m, m+r).\n\"m?\" is equivalent to interval(m + 5 precision units, m - 5 precision units).\n\"m??\" is equivalent to interval(-Inf, +Inf).\n\"m??d\" is equivalent to interval(-Inf, m).\n\"m??u\" is equivalent to interval(m, +Inf).\n\"[Entire]\", \"[entire]\" and \"[,]\" are equivalent to entireinterval().\n\"[Empty]\", \"[empty]\" and \"[]\" are equivalent to emptyinterval().\n\"[nai]\" and any other unsupported string formats are equivalent to nai().","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"To add a specific decoration, add \"_com\", \"_dac\", \"_dec\", \"_trv\" and \"_ill\" at the end of the string.","category":"page"},{"location":"manual/construction/","page":"Constructing intervals","title":"Constructing intervals","text":"danger: Danger\nMost real numbers cannot be exactly represented by floating-points. In such cases, the literal expression is rounded at parse time. To construct an interval enclosing the true real number, one must rely on the string constructor mentioned above.For instance, considerx = 0.1This appears to store the real number 110  in a variable x of type Float64. Yet,x > 1//10Hence, the floating-point 0.1 is (slightly) greater than the real number 110 since 110 cannot be represented exactly in binary floating-point arithmetic, at any precision. The true value must be approximated by a floating-point number with fixed precision – this procedure is called rounding.In particular, this implies that interval(0.1) does not contain the real number 110. A valid interval containing the real number 110 can be constructed byI\"0.1\"","category":"page"},{"location":"manual/usage/#Display-modes","page":"Usage","title":"Display modes","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"There are several useful output representations for intervals. The display is controlled globally by the setdisplay function, which has the following options:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"interval output format:\n:infsup: output of the form [1.09999, 1.30001], rounded to the current number of significant figures.\n:full: output of the form Interval(1.0999999999999999, 1.3), as in the showfull function.\n:midpoint: output in the midpoint-radius form, e.g. 1.2 ± 0.100001.\nsigfigs :: Int keyword argument: number of significant figures to show in standard mode.\ndecorations :: Bool keyword argument: whether to show decorations or not.","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"using IntervalArithmetic\na = interval(1.1, pi) # default display\nsetdisplay(; sigdigits = 10)\na\nsetdisplay(:full)\na\nsetdisplay(:midpoint)\na\nsetdisplay(; sigdigits = 4)\na\nsetdisplay(:infsup)\na","category":"page"},{"location":"manual/usage/#Arithmetic-operations","page":"Usage","title":"Arithmetic operations","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Basic arithmetic operations (+, -, *, /, ^) are defined for pairs of intervals in a standard way: the result is the smallest interval containing the result of operating with each element of each interval. More precisely, for two intervals X and Y and an operation bigcirc, we define the operation on the two intervals by","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X bigcirc Y bydef  x bigcirc y  x in X text and  y in Y ","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"For example,","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"using IntervalArithmetic\nsetdisplay(:full)\nX = interval(0, 1)\nY = interval(1, 2)\nX + Y","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Due to the above definition, subtraction of two intervals may give poor enclosures:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X - X","category":"page"},{"location":"manual/usage/#Elementary-functions","page":"Usage","title":"Elementary functions","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"The main elementary functions are implemented. The functions for Interval{Float64} internally use routines from the correctly-rounded CRlibm library where possible, i.e. for the following functions defined in that library:","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"exp, expm1\nlog, log1p, log2, log10\nsin, cos, tan\nasin, acos, atan\nsinh, cosh","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"Other functions that are implemented for Interval{Float64} internally convert to an Interval{BigFloat}, and then use routines from the MPFR library (BigFloat in Julia):","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"^\nexp2, exp10\natan, atanh","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"In particular, in order to obtain correct rounding for the power function (^), intervals are converted to and from BigFloat; this implies a significant slow-down in this case.","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"For example,","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"X = interval(1)\nsin(X)\ncos(cosh(X))\nsetprecision(BigFloat, 53)\nY = big(X)\nsin(Y)\ncos(cosh(Y))\nsetprecision(BigFloat, 128)\nsin(Y)","category":"page"},{"location":"manual/usage/#Comparisons-and-set-operations","page":"Usage","title":"Comparisons and set operations","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"All comparisons and set operations for Real have been purposely disallowed to prevent silent errors.","category":"page"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"interval(1) < interval(2)\nprecedes(interval(1), interval(2))\nissubset(interval(1, 2), interval(2))\nissubset_interval(interval(1, 2), interval(2))\nintersect(interval(1, 2), interval(2))\nintersect_interval(interval(1, 2), interval(2))","category":"page"},{"location":"manual/usage/#Custom-interval-bounds-type","page":"Usage","title":"Custom interval bounds type","text":"","category":"section"},{"location":"manual/usage/","page":"Usage","title":"Usage","text":"A BareInterval{T} or Interval{T} have the restriction T <: Union{Rational,AbstractFloat} which is the parametric type for the bounds of the interval. Supposing one wishes to use their own numeric type MyNumType <: Union{Rational,AbstractFloat}, they must provide their own arithmetic operations (with correct rounding!).","category":"page"},{"location":"#IntervalArithmetic.jl","page":"Home","title":"IntervalArithmetic.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntervalArithmetic.jl is a Julia package for validated numerics in Julia. All calculations are carried out using interval arithmetic where quantities are treated as intervals. The final result is a rigorous enclosure of the true value.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg # Julia v1.9 or above\nredirect_stderr(devnull) do # hide\nPkg.add(\"IntervalArithmetic\")\nend # hide","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use the IntervalArithmetic library in your publication, research, teaching, or other activities, please use the BibTeX template CITATION.bib.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MPFI.jl, a Julia wrapper around the MPFI C library, a multiple-precision interval arithmetic library based on MPFR\nIntervals.jl, an alternative implementation of basic interval functions by Invenia Technical Computing","category":"page"}]
}
