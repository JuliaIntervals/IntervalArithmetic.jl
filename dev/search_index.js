var documenterSearchIndex = {"docs":
[{"location":"interfaces/arblib/#Arblib.jl","page":"Arblib.jl","title":"Arblib.jl","text":"Arblib.jl is a Julia package for rigorous numerics based on ball arithmetic. It provides a thin and efficient wrapper around the parts of the C library FLINT that are concerned with real and complex numbers.\n\nThe purpose of the Arblib package extension is to make conversions between the types defined in IntervalArithmetic and Arblib straightforward. This allows for easy switching between the two packages, depending on which one suits a specific part of a computation best.\n\nSome of the things that Arblib excels at are:\n\nFast high precision computations, including linear algebra routines.\nA large library of special functions.\nSupport for mutable arithmetic.\nTaylor series expansions.\n\nSome of the things that IntervalArithmetic excels at are:\n\nFast computations at Float32 and Float64 precision.\nComputations with wide intervals (FLINT is in general not optimized for this, though the situation is improving).\nBuilt-in safety features, such as decorations (see Decorations) and the \"NG\" flag (see \"NG\" label).","category":"section"},{"location":"interfaces/arblib/#Conversion-between-Interval-and-Arblib-types","page":"Arblib.jl","title":"Conversion between Interval and Arblib types","text":"The fundamental types in Arblib are Arb and Acb, corresponding to real and complex balls respectively. Conversion between Interval and Arb, as well as between Complex{<:Interval} and Acb, is done through the standard constructors. If no type is specified when calling interval, it defaults to Interval{BigFloat} for Arb and Complex{Interval{BigFloat}} for Acb.\n\nusing IntervalArithmetic, Arblib\n\nx = interval(π)\nArb(x)\n\ny = Arb(π)\ninterval(y) # Defaults to BigFloat\ninterval(Float64, y) # Other type can be explicitly specified\n\nz = complex(interval(2), interval(1 // 3))\nAcb(z)\n\nw = Acb(2, 1 // 3)\ninterval(w)\ninterval(Float64, w)","category":"section"},{"location":"interfaces/arblib/#Linear-algebra","page":"Arblib.jl","title":"Linear algebra","text":"To use the optimized linear algebra routines from FLINT, the matrices should be converted to ArbMatrix or AcbMatrix (depending on whether they are real or complex). Basic methods can then be used directly:\n\nusing IntervalArithmetic, Arblib, LinearAlgebra\n\nA = interval.(BigFloat, [1 2; 3 4])\n\nB = ArbMatrix(A)\n\nB * B\n\ninv(B)\n\nB \\ B\n\neigvals(AcbMatrix(B)) # Eigenvalues are only supported for AcbMatrix\n\nFull documentation about supported methods can be found in the FLINT documentation for arb_mat and acb_mat. Note that many of these methods are not wrapped in Arblib, but most of them can be used through a low level wrapper.","category":"section"},{"location":"interfaces/arblib/#Special-functions","page":"Arblib.jl","title":"Special functions","text":"Arblib wraps a large number of the special functions from SpecialFunctions.jl.\n\nusing IntervalArithmetic, Arblib, SpecialFunctions\n\nx = interval(BigFloat, 2)\n\ninterval(besselj0(Arb(x))) # Convert to Arb and then back\n\ninterval(gamma(Arb(x)))\n\ninterval(zeta(Arb(x)))\n\nNote that FLINT implements several special functions that are not in SpecialFunctions.jl, such as the confluent hypergeometric functions and the Lerch transcendent; they can be used through the low-level wrapper:\n\nusing IntervalArithmetic, Arblib\n\nz = interval(BigFloat, 2 + 3im)\ns = interval(BigFloat, 2)\na = interval(BigFloat, 4)\n\ninterval(Arblib.dirichlet_lerch_phi!(Acb(), Acb(z), Acb(s), Acb(a)))","category":"section"},{"location":"manual/guarantee/#Guaranteed-intervals","page":"Guarantee and ExactReal","title":"Guaranteed intervals","text":"A guaranteed interval is a concept distinct from decorations (see Decorations) and not specified in the IEEE 1788-2015 standard. It is introduced to accommodate Julia’s flexible system of type conversion and promotion, while retaining reliability in computations.","category":"section"},{"location":"manual/guarantee/#\"NG\"-label","page":"Guarantee and ExactReal","title":"\"NG\" label","text":"An interval x constructed via interval satisfies isguaranteed(x) == true. However, if a call to convert(::Type{<:Interval}, ::Real) occurs, then the resulting interval x satisfies isguaranteed(x) == false, receiving the \"NG\" (not guaranteed) label.\n\nFor instance, consider the following examples:\n\nusing IntervalArithmetic\nsetdisplay(; sigdigits = 6)\nconvert(Interval{Float64}, 1.) # considered \"not guaranteed\" as this call can be done implicitly\ninterval(1) # considered \"guaranteed\" as the user explicitly constructed the interval\n\nIn contrast, a BareInterval can only be constructed via bareinterval, it is not a subtype of Real, and there are no allowed conversion with Number. Thus, this interval type is always guaranteed.\n\ndanger: Danger\nA user interested in validated numerics should always track down the source of an \"NG\" label.","category":"section"},{"location":"manual/guarantee/#Exact-numbers","page":"Guarantee and ExactReal","title":"Exact numbers","text":"When typing Julia code, it is combersome to manually wrap all numerical numbers with interval. Also, we sometimes want to use the same function for both floating-point arithmetic (maybe to check have a fast quick checks) and interval arithmetic. Then, we would want the typed-in numerical numbers to convert automatically to the appropriate numerical type depending on the context. To this end, the ExactReal structure marks any Real number as a user exactly typed-in value.\n\nFor instance, consider the following examples:\n\ninterval(1)\ninterval(1) + exact(1)\n@exact 2interval(1) + 1 + exp(im * interval(1))\n@exact foo(x) = 2x + 1 + exp(im * x)\nfoo(1.)\nfoo(interval(1))","category":"section"},{"location":"examples/pi/","page":"Rigorous computation of pi","title":"Rigorous computation of pi","text":"In this example, we compute rigorous bounds on pi using interval arithmetic[1], via the IntervalArithmetic.jl package.\n\n[1]: W. Tucker, Validated Numerics: A Short Introduction to Rigorous Computations, Princeton University Press, 2011.\n\nThere are many ways to calculate pi. For illustrative purposes, we will use the following sum\n\nS bydef sum_n=1^infty frac1n^2\n\nAccording to the Basel Problem, the exact value is S = fracpi^26. Thus, if we can calculate a rigorous enclosure of S, then we can deduce a rigorous enclosure of pi.\n\nFirst, we split S into a finite and infinite part, S = S_N + T_N, where\n\nS_N bydef sum_n=1^N frac1n^2 qquad\nT_N bydef S - S_N = sum_n=N+1^infty frac1n^2\n\nUsing integrals from below and above, we obtain frac1N+1 le T_N le frac1N. It remains to compute rigorous bounds for S_N, which can be found by calculating the sum using interval arithmetic:\n\nusing IntervalArithmetic\n\nfunction forward_sum(N)\n    S_N = interval(0)\n\n    for i ∈ 1:N\n        S_N += interval(1) / interval(i) ^ interval(2)\n    end\n\n    T_N = interval(1) / interval(N, N+1)\n\n    S = S_N + T_N\n\n    return sqrt(interval(6) * S)\nend\n\npi_interval = forward_sum(10^6)\n\nmidradius(pi_interval)\n\nThe above computation shows that the midpoint of the computed interval is correct to about 10 decimal places. We can also verify directly that pi is indeed contained in the interval:\n\nin_interval(π, pi_interval)\n\nLastly, let us note that, due to floating-point arithmetic, computing the sum in the opposite direction yields a more accurate answer:\n\nfunction backward_sum(N)\n    S_N = interval(0)\n\n    for i ∈ N:-1:1\n        S_N += interval(1) / interval(i) ^ interval(2)\n    end\n\n    T_N = interval(1) / interval(N, N+1)\n\n    S = S_N + T_N\n\n    return sqrt(interval(6) * S)\nend\n\nimproved_pi_interval = backward_sum(10^6)\n\nmidradius(improved_pi_interval)","category":"section"},{"location":"manual/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"manual/api/#IntervalArithmetic.IntervalArithmetic","page":"API","title":"IntervalArithmetic.IntervalArithmetic","text":"IntervalArithmetic\n\nLibrary for validated numerics using interval arithmetic. It provides tools for performing numerical calculations with guaranteed bounds by representing values as intervals: computed results enclose the true value. It is well-suited for computer-assisted proofs, and any context requiring certified numerics.\n\nLearn more: https://github.com/JuliaIntervals/IntervalArithmetic.jl.\n\nConfiguration options\n\nThe behavior and performance of the library can be customized through the following parameters. All defaults can be modified using IntervalArithmetic.configure.\n\nBound Type: The default numerical type used for interval endpoints. The default is Float64, but any subtype of IntervalArithmetic.NumTypes may be used to adjust precision, or specific numerical requirements.\nFlavor: The interval interpretation according to the IEEE Standard 1788-2015. The default is the set-based flavor, which excludes infinity from intervals. Learn more: IntervalArithmetic.Flavor.\nInterval Rounding: The rounding behavior for interval arithmetic operations. By default, the library employs correct rounding to ensure that bounds are computed as tightly as possible. Learn more: IntervalArithmetic.IntervalRounding.\nPower mode: The performance setting for computing powers. The default is an efficient algorithm prioritizing performance over precision. Learn more: IntervalArithmetic.PowerMode.\nMatrix Multiplication mode: The performance setting for computing matrix multiplications. The default is an efficient algorithm prioritizing performance over precision. Learn more: IntervalArithmetic.MatMulMode.\n\nDisplay settings\n\nThe display of intervals is controlled by setdisplay. By default, the intervals are shown using the standard mathematical notation a b, along with decorations and up to 6 significant digits.\n\n\n\n\n\n","category":"module"},{"location":"manual/api/#IntervalArithmetic.BareInterval","page":"API","title":"IntervalArithmetic.BareInterval","text":"BareInterval{T<:NumTypes}\n\nInterval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015. Unlike Interval, this bare interval does not have decorations, is not a subtype of Real and errors on operations mixing BareInterval and Number.\n\nFields:\n\nlo :: T\nhi :: T\n\nConstructor compliant with the IEEE Standard 1788-2015: bareinterval.\n\nSee also: Interval.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Constant","page":"API","title":"IntervalArithmetic.Constant","text":"Constant(value)\n\nA constant function compatible with interval arithmetic.\n\nReturn an interval containing only the value for an interval input, and the value directly otherwise.\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> c = Constant(1.2)\nConstant{Float64}(1.2)\n\njulia> c(22.2)\n1.2\n\njulia> c(interval(0, 1.3))\nInterval{Float64}(1.2, 1.2, com, true)\n\nNote that this is not equivalent to Returns(value) from base, which always outputs value, even for an interval input. This can shortcircuit the propagation of intervals in the computation and lose the associated guarantee of correctness.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Domain","page":"API","title":"IntervalArithmetic.Domain","text":"Domain{LeftBound, RightBound}(lo, hi)\n\nThe domain of a function.\n\nLeftBound and RightBound must be symbols and are either :closed or :open determining if the corresponding endpoint is (respectively) included or not in the domain.\n\nIf hi > lo, the domain is considered to be empty.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.ExactReal","page":"API","title":"IntervalArithmetic.ExactReal","text":"ExactReal{T<:Real} <: Real\n\nReal numbers with the assurance that they precisely correspond to the number described by their binary form. The purpose is to guarantee that a non interval number is exact, so that ExactReal can be used with Interval without producing the \"NG\" flag.\n\nAn ExactReal is constructed by wrapping the value with exact.\n\nSee also: @exact\n\ndanger: Danger\nBy using ExactReal, users acknowledge the responsibility of ensuring that the number they input corresponds to their intended value. For example, exact(0.1) implies that the user knows that 01 can not be represented exactly as a binary number, and that they are using a slightly different number than 01. To help identify the binary number, ExactReal is displayed without any rounding up to 2000 decimals.julia> exact(0.1)\nExactReal{Float64}(0.1000000000000000055511151231257827021181583404541015625)In case of doubt, has_exact_display can be use to check if the string representation of a Real is equal to its binary value (up to 2000 decimals).\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> 0.5 * interval(1)\nInterval{Float64}(0.5, 0.5, com, false)\n\njulia> exact(0.5) * interval(1)\nInterval{Float64}(0.5, 0.5, com, true)\n\njulia> setdisplay(:infsup);\n\njulia> [1, interval(2)]\n2-element Vector{Interval{Float64}}:\n [1.0, 1.0]_com_NG\n [2.0, 2.0]_com\n\njulia> [exact(1), interval(2)]\n2-element Vector{Interval{Float64}}:\n [1.0, 1.0]_com\n [2.0, 2.0]_com\n\nSee also: @exact.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Interval","page":"API","title":"IntervalArithmetic.Interval","text":"Interval{T<:NumTypes} <: Real\n\nInterval type for guaranteed computation with interval arithmetic according to the IEEE Standard 1788-2015. This structure combines a BareInterval together with a Decoration.\n\nFields:\n\nbareinterval :: BareInterval{T}\ndecoration   :: Decoration\nisguaranteed :: Bool\n\nConstructors compliant with the IEEE Standard 1788-2015:\n\ninterval\n..\n±\n@I_str\n\nSee also: ±, .. and @I_str.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.Piecewise","page":"API","title":"IntervalArithmetic.Piecewise","text":"Piecewise(pairs... ; continuity = fill(-1, length(pairs) - 1))\n\nA function defined by pieces (each associating a domain to a function). Support both intervals and standard numbers.\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> myabs = Piecewise(\n          Domain{:open, :closed}(-Inf, 0) => x -> -x,\n          Domain{:open, :open}(0, Inf) => identity\n       );\n\njulia> myabs(-22.3)\n22.3\n\njulia> myabs(interval(-5, 5))\nInterval{Float64}(0.0, 5.0, def, true)\n\nFor constant pieces, it is recommended to use Constant for full compatibility with intervals.\n\nThe domains must be specified in increasing order and must not overlap.\n\nThe continuity optional argument takes a vector of N - 1 integers (where  N is the number of domains) determining how the piecewise function behaves at the endpoints between the subdomains. The possibility are:\n\n-1 : the function is discontinuous between the domains.\n0 : the function is continuous but not differentiable between the domains.\nn > 0 : the function is n times continuously differentiable between the   domains. This only matter when using ForwardDiff to compute derivative   of the function.\n\nThis information is used to determine the decoration of intervals that covers the endpoint of several domains.\n\nIf an input interval goes outside the domain of definition of the piecewise function, the output will always have the trivial (trv) decoration. For standard number, it throws a DomainError.\n\nThe piecewise function can have a gap between two pieces. In this case, the continuity optional argument is ignored, and interval spanning over the gap always as the trv decoration.\n\n\n\n\n\n","category":"type"},{"location":"manual/api/#IntervalArithmetic.bareinterval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}} where T","page":"API","title":"IntervalArithmetic.bareinterval","text":"bareinterval(T, a, b)\n\nCreate the bare interval a b according to the IEEE Standard 1788-2015. The validity of the interval is checked by is_valid_interval: if true then a BareInterval{T} is constructed, otherwise an empty interval is returned.\n\ndanger: Danger\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, parse the string containing the desired value to ensure its tight enclosure.\n\nSee also: interval, ±, .. and @I_str.\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> bareinterval(1//1, π)\nBareInterval{Rational{Int64}}(1//1, 85563208//27235615)\n\njulia> bareinterval(Rational{Int32}, 1//1, π)\nBareInterval{Rational{Int32}}(1//1, 85563208//27235615)\n\njulia> bareinterval(1, π)\nBareInterval{Float64}(1.0, 3.1415926535897936)\n\njulia> bareinterval(BigFloat, 1, π)\nBareInterval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bisect-Union{Tuple{BareInterval{T}}, Tuple{T}, Tuple{BareInterval{T}, Real}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.bisect","text":"bisect(x, α=0.5)\nbisect(x, i, α=0.5)\n\nSplit an interval x at a relative position α, where α = 0.5 corresponds to the midpoint.\n\nSplit the i-th component of a vector x at a relative position α, where α = 0.5 corresponds to the midpoint.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.bounds-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.bounds","text":"bounds(x)\n\nBounds of x given as a tuple. Unlike inf, this function does not normalize the infimum of the interval.\n\nSee also: inf, sup, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.cancelminus-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.cancelminus","text":"cancelminus(x, y; dec = :default)\n\nCompute the unique interval z such that y + z == x.\n\nThe keywork dec argument controls the decoration of the result. It can be either a specific decoration, or one of two following options:     - :default: if at least one of the input intervals is ill,         then the result is ill, otherwise it is trv (Section 11.7.1).     - :auto: the ouptut has the minimal decoration of the inputs.\n\nImplement the cancelMinus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.cancelplus-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.cancelplus","text":"cancelplus(x, y; dec = :default)\n\nCompute the unique interval z such that y - z == x; this is semantically equivalent to cancelminus(x, -y).\n\nThe keywork dec argument controls the decoration of the result. It can be either a specific decoration, or one of two following options:     - :default: if at least one of the input intervals is ill,         then the result is ill, otherwise it is trv (Section 11.7.1).     - :auto: the ouptut has the minimal decoration of the inputs.\n\nImplement the cancelPlus function of the IEEE Standard 1788-2015 (Section 9.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.diam-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.diam","text":"diam(x)\n\nDiameter of x. If x is complex, then the diameter is the maximum diameter between its real and imaginary parts.\n\nImplement the wid function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, mid, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.dist-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.dist","text":"dist(x, y)\n\nDistance between x and y.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.emptyinterval-Union{Tuple{Type{BareInterval{T}}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.emptyinterval","text":"emptyinterval(T=[default_numtype()])\n\nCreate an empty interval. This interval is an exception to the fact that the lower bound is larger than the upper one.\n\nImplement the empty function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.entireinterval-Union{Tuple{Type{BareInterval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.entireinterval","text":"entireinterval(T=[default_numtype()])\n\nCreate an interval representing the entire real line, or the entire complex plane if T is complex.\n\nnote: Note\nDepending on the flavor, infinity may or may not be considered part of the interval.\n\nImplement the entire function of the IEEE Standard 1788-2015 (Section 10.5.2).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.extended_div-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.extended_div","text":"extended_div(x, y)\n\nTwo-output division.\n\nImplement the mulRevToPair function of the IEEE Standard 1788-2015 (Section 10.5.5).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.fastpow-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.fastpow","text":"fastpow(x, y)\n\nA faster implementation of pow(x, y), at the cost of maybe returning a larger interval.\n\nSee also: pow, pown and fastpown.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.fastpown-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.fastpown","text":"fastpown(x, n)\n\nA faster implementation of pown(x, n), at the cost of maybe returning a larger interval.\n\nSee also: pown, pow and fastpow.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.has_exact_display-Tuple{Real}","page":"API","title":"IntervalArithmetic.has_exact_display","text":"has_exact_display(x::Real)\n\nDetermine if the display of x up to 2000 decimals is equal to the bitwise value of x. This is famously not true for the float displayed as 0.1.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.hull-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.hull","text":"hull(x, y; dec = :default)\n\nReturn the interval hull of the intervals x and y, considered as (extended) sets of real numbers, i.e. the smallest interval that contains all of x and y.\n\nThe keywork dec argument controls the decoration of the result. It can be either a specific decoration, or one of two following options:     - :default: if at least one of the input intervals is ill,         then the result is ill, otherwise it is trv (Section 11.7.1).     - :auto: the ouptut has the minimal decoration of the inputs.\n\nImplement the convexHull function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.in_interval-Tuple{Number, BareInterval}","page":"API","title":"IntervalArithmetic.in_interval","text":"in_interval(x, y)\n\nTest whether x is an element of y.\n\nImplement the isMember function of the IEEE Standard 1788-2015 (Sections 10.6.3 and 12.13.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.inf-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.inf","text":"inf(x)\n\nLower bound, or infimum, of x. For a zero AbstractFloat lower bound, a negative zero is returned.\n\nImplement the inf function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: sup, bounds, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.interiordiff-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.interiordiff","text":"interiordiff(x, y; dec = :default)\n\nRemove the interior of y from x. If x and y are vectors, then they are treated as multi-dimensional intervals.\n\nThe keywork dec argument controls the decoration of the result. It can be either a specific decoration, or one of two following options:     - :default: if at least one of the input intervals is ill,         then the result is ill, otherwise it is trv (Section 11.7.1).     - :auto: the ouptut has the minimal decoration of the inputs.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.intersect_interval-Union{Tuple{T}, Tuple{BareInterval{T}, BareInterval{T}}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.intersect_interval","text":"intersect_interval(x, y; dec = :default)\n\nReturns the intersection of the intervals x and y, considered as (extended) sets of real numbers. That is, the set that contains the points common in x and y.\n\nThe keywork dec argument controls the decoration of the result. It can be either a specific decoration, or one of two following options:     - :default: if at least one of the input intervals is ill,         then the result is ill, otherwise it is trv (Section 11.7.1).     - :auto: the ouptut has the minimal decoration of the inputs.\n\nImplement the intersection function of the IEEE Standard 1788-2015 (Section 9.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.interval-Union{Tuple{T}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, IntervalArithmetic.Decoration}} where T","page":"API","title":"IntervalArithmetic.interval","text":"interval([T,] a, b, d = com; format = :infsup)\n\nCreate the interval a b according to the IEEE Standard 1788-2015. The validity of the interval is checked by is_valid_interval: if true then an Interval{T} is constructed, otherwise an NaI (Not an Interval) is returned.\n\ndanger: Danger\nNothing is done to compensate for the fact that floating point literals are rounded to the nearest when parsed (e.g. 0.1). In such cases, parse the string containing the desired value to ensure its tight enclosure.\n\nSee also: ±, .. and @I_str.\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> interval(1//1, π)\nInterval{Rational{Int64}}(1//1, 85563208//27235615, com, true)\n\njulia> interval(Rational{Int32}, 1//1, π)\nInterval{Rational{Int32}}(1//1, 85563208//27235615, com, true)\n\njulia> interval(1, π)\nInterval{Float64}(1.0, 3.1415926535897936, com, true)\n\njulia> interval(BigFloat, 1, π)\nInterval{BigFloat}(1.0, 3.141592653589793238462643383279502884197169399375105820974944592307816406286233, com, true)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isatomic-Tuple{BareInterval{<:AbstractFloat}}","page":"API","title":"IntervalArithmetic.isatomic","text":"isatomic(x)\n\nTest whether x is unable to be split. This occurs if the interval is empty, or if its lower and upper bounds are equal, or if the bounds are consecutive floating-point numbers.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isbounded-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isbounded","text":"isbounded(x)\n\nTest whether x is empty or has finite bounds.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.iscommon-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.iscommon","text":"iscommon(x)\n\nTest whether x is not empty and bounded.\n\nImplement the isCommonInterval function of the IEEE Standard 1788-2015 (Sections 10.6.3 and 12.13.3).\n\nnote: Note\nThis does not take into consideration the decoration of the interval.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isdisjoint_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isdisjoint_interval","text":"isdisjoint_interval(x, y, z...)\n\nTest whether the given intervals have no common elements.\n\nImplement the disjoint function of the IEEE Standard 1788-2015. (Tables 9.3 and 10.3, and Sections 9.5, 10.5.10 and 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isempty_interval-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.isempty_interval","text":"isempty_interval(x)\n\nTest whether x contains no elements.\n\nImplement the isEmpty function of the IEEE Standard 1788-2015 (Sections 10.5.10 and 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isentire_interval-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.isentire_interval","text":"isentire_interval(x)\n\nTest whether x is the entire real line.\n\nImplement the isEntire function of the IEEE Standard 1788-2015 (Sections 10.5.10 and 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isequal_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isequal_interval","text":"isequal_interval(x, y)\n\nTest whether x and y are identical.\n\nImplement the equal function of the IEEE Standard 1788-2015 (Tables 9.3 and 10.3, and Sections 9.5, 10.5.10 and 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isguaranteed-Tuple{Interval}","page":"API","title":"IntervalArithmetic.isguaranteed","text":"isguaranteed(x::BareInterval)\nisguaranteed(x::Interval)\nisguaranteed(x::Complex{<:Interval})\n\nTest whether the interval is not guaranteed to encompass all possible numerical errors. This happens whenever an Interval is constructed using convert(::Type{<:Interval}, ::Real), which may occur implicitly when mixing intervals and Real types.\n\nSince conversion between BareInterval and Number is prohibited, this implies that isguaranteed(::BareInterval) == true.\n\nIn the case of a complex interval x, this is semantically equivalent to isguaranteed(real(x)) & isguaranteed(imag(x)).\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> isguaranteed(bareinterval(1))\ntrue\n\njulia> isguaranteed(interval(1))\ntrue\n\njulia> isguaranteed(convert(Interval{Float64}, 1))\nfalse\n\njulia> isguaranteed(interval(1) + 0)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isinterior-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isinterior","text":"isinterior(x, y)\n\nTest whether x is in the interior of y.\n\nImplement the interior function of the IEEE Standard 1788-2015 (Tables 9.3 and 10.3, and Sections 9.5, 10.5.10 and 12.12.9).\n\nSee also: issubset_interval and isstrictsubset.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isnai-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isnai","text":"isnai(x)\n\nTest whether x is an NaI (Not an Interval).\n\nImplement the isNaI function of the IEEE Standard 1788-2015 (Section 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.issetequal_interval","page":"API","title":"IntervalArithmetic.issetequal_interval","text":"issetequal_interval(x, y)\n\nReturn whether the two interval are identical when considered as sets.\n\nAlias of the isequal_interval function.\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.isstrictless-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isstrictless","text":"isstrictless(x, y)\n\nTest whether inf(x) < inf(y) and sup(x) < sup(y), where < is replaced by ≤ for infinite values.\n\nImplement the strictLess function of the IEEE Standard 1788-2015 (Table 10.3, and Sections 10.5.10 and 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isstrictsubset-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isstrictsubset","text":"isstrictsubset(x, y)\n\nTest whether x is a subset of, but not equal to, y. If x and y are vectors, x must be a subset of y with at least one of their component being a strict subset.\n\nSee also: issubset_interval and isinterior.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.issubset_interval-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.issubset_interval","text":"issubset_interval(x, y)\n\nTest whether x is contained in y.\n\nImplement the subset function of the IEEE Standard 1788-2015 (Tables 9.3 and 10.3, and Sections 9.5, 10.5.10 and 12.12.9).\n\nSee also: isstrictsubset and isinterior.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthin-Tuple{BareInterval, Number}","page":"API","title":"IntervalArithmetic.isthin","text":"isthin(x, y)\n\nTest whether x contains only y.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthin-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthin","text":"isthin(x)\n\nTest whether x contains only a real.\n\nImplement the isSingleton function of the IEEE Standard 1788-2015 (Sections 10.6.3 and 12.13.3).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthininteger-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthininteger","text":"isthininteger(x)\n\nTest whether x contains only an integer.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthinone-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthinone","text":"isthinone(x)\n\nTest whether x contains only one.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isthinzero-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isthinzero","text":"isthinzero(x)\n\nTest whether x contains only zero.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isunbounded-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.isunbounded","text":"isunbounded(x)\n\nTest whether x is not empty and has infinite bounds.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.isweakless-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.isweakless","text":"isweakless(x, y)\n\nTest whether inf(x) ≤ inf(y) and sup(x) ≤ sup(y), where < is replaced by ≤ for infinite values.\n\nImplement the less function of the IEEE Standard 1788-2015 (Table 10.3, and Sections 10.5.10 and 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mag-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.mag","text":"mag(x)\n\nMagnitude of x.\n\nImplement the mag function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: mig.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mid-Union{Tuple{BareInterval{T}}, Tuple{T}, Tuple{BareInterval{T}, Any}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.mid","text":"mid(x, α = 0.5)\n\nRelative midpoint of x, for α between 0 and 1 such that mid(x, 0) is the lower bound of the interval, mid(x, 1) its upper bound, and mid(x, 0.5) its midpoint.\n\nImplement the mid function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.midradius-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.midradius","text":"midradius(x)\n\nMidpoint and radius of x.\n\nFunction required by the IEEE Standard 1788-2015 in Section 10.5.9 for the set-based flavor.\n\nSee also: inf, sup, bounds, mid, mid and radius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mig-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mig","text":"mig(x)\n\nMignitude of x.\n\nImplement the mig function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: mag.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince!-Union{Tuple{T}, Tuple{AbstractVector{<:BareInterval}, BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mince!","text":"mince!(v, x, n)\n\nIn-place version of mince.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.mince-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.mince","text":"mince(x, n)\n\nSplit an interval x in n intervals of the same diameter.\n\nSplit the i-th component of a vector x in n[i] intervals of the same diameter; n can be a tuple of integers, or a single integer in which case the same n is used for all the components of x.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.nai-Union{Tuple{Type{Interval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.nai","text":"nai(T=[default_numtype()])\n\nCreate an NaI (Not an Interval).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.numtype-Union{Tuple{Type{BareInterval{T}}}, Tuple{T}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.numtype","text":"numtype(T)\n\nReturn the bound type of the interval.\n\nExamples\n\njulia> numtype(interval(1, 2))\nFloat64\n\njulia> numtype(interval(Float32, 1, 2))\nFloat32\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.overlap-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.overlap","text":"overlap(x::BareInterval, y::BareInterval)\noverlap(x::Interval, y::Interval)\n\nImplement the overlap function of the IEEE Standard 1788-2015 (Table 10.7).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.pow-Tuple{Any, Any}","page":"API","title":"IntervalArithmetic.pow","text":"pow(x, y)\n\nCompute the power of the positive real part of x by y. In particular, even if y is a thin integer, this is not equivalent to pown(x, sup(y)).\n\nImplement the pow function of the IEEE Standard 1788-2015 (Table 9.1).\n\nSee also: fastpow, pown and fastpown.\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> pow(bareinterval(2, 3), bareinterval(2))\nBareInterval{Float64}(4.0, 9.0)\n\njulia> pow(interval(-1, 1), interval(3))\nInterval{Float64}(0.0, 1.0, trv, true)\n\njulia> pow(interval(-1, 1), interval(-3))\nInterval{Float64}(1.0, Inf, trv, true)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.pown-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:Union{AbstractFloat, Rational}","page":"API","title":"IntervalArithmetic.pown","text":"pown(x, n)\n\nImplement the pown function of the IEEE Standard 1788-2015 (Table 9.1).\n\nSee also: fastpown, pow and fastpow.\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> pown(bareinterval(2, 3), 2)\nBareInterval{Float64}(4.0, 9.0)\n\njulia> pown(interval(-1, 1), 3)\nInterval{Float64}(-1.0, 1.0, com, true)\n\njulia> pown(interval(-1, 1), -3)\nInterval{Float64}(-Inf, Inf, trv, true)\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.precedes-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.precedes","text":"precedes(x, y)\n\nTest whether any element of x is lesser or equal to every elements of y.\n\nImplement the precedes function of the IEEE Standard 1788-2015 (Table 10.3, and Sections 10.5.10 and 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.radius-Tuple{BareInterval}","page":"API","title":"IntervalArithmetic.radius","text":"radius(x)\n\nRadius of x, such that issubset_interval(x, mid(x) ± radius(x)). If x is complex, then the radius is the maximum radius between its real and imaginary parts.\n\nImplement the rad function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, sup, bounds, mid, diam and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.rootn-Union{Tuple{T}, Tuple{BareInterval{T}, Integer}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.rootn","text":"rootn(x::BareInterval, n::Integer)\n\nCompute the real n-th root of x.\n\nImplement the rootn function of the IEEE Standard 1788-2015 (Table 9.1).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.setdisplay","page":"API","title":"IntervalArithmetic.setdisplay","text":"setdisplay(format::Symbol; decorations::Bool, ng_flag::Bool, sigdigits::Int)\n\nChange the format used by show to display intervals.\n\nPossible options:\n\nformat can be:\n:infsup: display intervals as [a, b].\n:midpoint: display intervals as m ± r.\n:full: display interval bounds entirely, ignoring sigdigits.\ndecorations: display the decorations or not.\nng_flag: display the NG flag or not.\nsigdigits: number (greater or equal to 1) of significant digits to display.\n\nInitially, the display options are set to setdisplay(:infsup; decorations = true, ng_flag = true, sigdigits = 6). If any of format, decorations, ng_flag and sigdigits is omitted, then their value is left unchanged.\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full)\nDisplay options:\n  - format: full\n  - decorations: true (ignored)\n  - NG flag: true (ignored)\n  - significant digits: 6 (ignored)\n\njulia> x = interval(0.1, 0.3)\nInterval{Float64}(0.1, 0.3, com, true)\n\njulia> setdisplay(:infsup; sigdigits = 3)\nDisplay options:\n  - format: infsup\n  - decorations: true\n  - NG flag: true\n  - significant digits: 3\n\njulia> x\n[0.1, 0.3]_com\n\njulia> setdisplay(; decorations = false)\nDisplay options:\n  - format: infsup\n  - decorations: false\n  - NG flag: true\n  - significant digits: 3\n\njulia> x\n[0.1, 0.3]\n\njulia> setdisplay(:infsup; decorations = true, ng_flag = true, sigdigits = 6) # default display options\nDisplay options:\n  - format: infsup\n  - decorations: true\n  - NG flag: true\n  - significant digits: 6\n\njulia> x\n[0.1, 0.3]_com\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.strictprecedes-Tuple{BareInterval, BareInterval}","page":"API","title":"IntervalArithmetic.strictprecedes","text":"strictprecedes(x, y)\n\nTest whether any element of x is strictly lesser than every elements of y.\n\nImplement the strictPrecedes function of the IEEE Standard 1788-2015 (Table 10.3, and Sections 10.5.10 and 12.12.9).\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.sup-Union{Tuple{BareInterval{T}}, Tuple{T}} where T<:AbstractFloat","page":"API","title":"IntervalArithmetic.sup","text":"sup(x)\n\nUpper bound, or supremum, of x.\n\nImplement the sup function of the IEEE Standard 1788-2015 (Table 9.2).\n\nSee also: inf, bounds, mid, diam, radius and midradius.\n\n\n\n\n\n","category":"method"},{"location":"manual/api/#IntervalArithmetic.union_interval","page":"API","title":"IntervalArithmetic.union_interval","text":"union_interval(x, y, z...)\n\nAlias of hull.\n\n\n\n\n\n","category":"function"},{"location":"manual/api/#IntervalArithmetic.@I_str-Tuple{Any}","page":"API","title":"IntervalArithmetic.@I_str","text":"I\"str\"\n\nCreate an interval by parsing the string \"str\"; this is semantically equivalent to parse(Interval{default_numtype()}, \"str\").\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> I\"[3, 4]\"\nInterval{Float64}(3.0, 4.0, com, true)\n\njulia> I\"0.1\"\nInterval{Float64}(0.09999999999999999, 0.1, com, true)\n\njulia> in_interval(1//10, I\"0.1\")\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.@exact-Tuple{Any}","page":"API","title":"IntervalArithmetic.@exact","text":"@exact\n\nWrap every literal numbers of the expression in an ExactReal. This macro allows defining generic functions, seamlessly accepting both Number and Interval arguments, without producing the \"NG\" flag.\n\ndanger: Danger\nBy using ExactReal, users acknowledge the responsibility of ensuring that the number they input corresponds to their intended value. For example, exact(0.1) implies that the user knows that 01 can not be represented exactly as a binary number, and that they are using a slightly different number than 01. To help identify the binary number, ExactReal is displayed without any rounding up to 2000 decimals.julia> exact(0.1)\nExactReal{Float64}(0.1000000000000000055511151231257827021181583404541015625)In case of doubt, has_exact_display can be use to check if the string representation of a Real is equal to its binary value (up to 2000 decimals).\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:infsup);\n\njulia> f(x) = 1.2 * x + 0.1\nf (generic function with 1 method)\n\njulia> f(interval(1, 2))\n[1.3, 2.5]_com_NG\n\njulia> @exact g(x) = 1.2 * x + 0.1\ng (generic function with 1 method)\n\njulia> g(interval(1, 2))\n[1.3, 2.5]_com\n\njulia> g(1.4)\n1.78\n\nSee also: ExactReal.\n\n\n\n\n\n","category":"macro"},{"location":"manual/api/#IntervalArithmetic.@interval-Tuple{Any}","page":"API","title":"IntervalArithmetic.@interval","text":"@interval([T], expr)\n@interval([T], expr1, expr2)\n\nWalk through an expression and wrap each argument of functions with the internal constructor atomic.\n\nExamples\n\njulia> using IntervalArithmetic\n\njulia> setdisplay(:full);\n\njulia> @interval sin(1) # Float64 is the default bound type\nInterval{Float64}(0.8414709848078965, 0.8414709848078966, com, true)\n\njulia> @interval Float32 sin(1)\nInterval{Float32}(0.84147096f0, 0.841471f0, com, true)\n\njulia> @interval Float64 sin(1) exp(1)\nInterval{Float64}(0.8414709848078965, 2.7182818284590455, com, true)\n\n\n\n\n\n","category":"macro"},{"location":"philosophy/#Philosophy","page":"Philosophy","title":"Philosophy","text":"The goal of the Interval type is to be directly used to replace floating point numbers in arbitrary julia code, such that, in any calculation, the resulting interval is guaranteed to bound the true image of the starting intervals.\n\nSo, essentially, we would like Interval to act as numbers. And the julia ecosystem has evolved to use Real as the default supertype for numerical types that are not complex. Therefore, to ensure the widest compatiblity, our Interval type must be a subtype of Real.\n\nMathematically, for any function f(x::Real), we want the following to hold (note that it holds for all real numbers in X, even those that cannot be represented as floating point numbers):\n\nf(x) in f(X) qquad forall x in X\n\nThe interval-valued function f(X) is called the pointwise extension of f(x) (which is defined on real numbers).\n\nAt first glance, this is reasonable: all arithmetic operations are well-defined for both real numbers and intervals, therefore we can use multiple dispatch to define the interval behavior of operations such has +, /, sin or log. Then a code written for Reals can be used as is with Intervals.\n\nHowever, being a Real means way more than just being compatible with arithmetic operations. Reals are also expected to\n\nBe compatible with any other Number through promotion.\nSupport comparison operations, such as == or <.\nAct as a container of a single element, e.g. collect(x) returns a 0-dimensional array containing x.\n\nEach of those points lead to specific design choices for IntervalArithmetic.jl, choices that we detail below.","category":"section"},{"location":"philosophy/#Compatibility-with-other-Numbers","page":"Philosophy","title":"Compatibility with other Numbers","text":"In julia it is expected that 1 + 2.2 silently promoted the integer 1 to a Float64 to be able to perform the addition. Following this logic, it means that 0.1 + interval(2.2, 2.3) should silently promote 0.1 to an interval.\n\nHowever, in this case we cannot guarantee that 0.1 is known exactly, because we do not know how it was produced in the first place (it could be contain numerical inaccuracy from another computation from example). Following the julia convention is thus in contradiction with providing guaranteed result.\n\nIn this case, we choose to be mostly silent, the information that a non-interval of unknown origin is recorded in the NG flag, but the calculation is not interrupted, and no warning is printed. If an interval is flagged with NG it means that it was produced through promotion of real numbers from unknown origin, for example\n\njulia> X = interval(1, 2)\n[1.0, 2.0]_com  # The interval is guaranteed because it was explicitly created\n\njulia> X + 0.1\n[1.1, 2.1]_com_NG  # The NG flag appears, because 0.1 is not provably exact\n\nFor convenience, we provide the ExactReal and @exact macro to allow explicitly marking a number as being exact, and not produce the NG flag when mixed with intervals.\n\nNote that this still assume that all interval inputs are correct. Please see the contructors page for more information about potential caveats.","category":"section"},{"location":"philosophy/#Comparison-operators","page":"Philosophy","title":"Comparison operators","text":"We can extend the definition of the pointwise extension of a function f for two real numbers x and y, and their respective intervals X and Y, as\n\nf(x y) in f(X Y) qquad forall x in X y in Y\n\nWith this in mind, an operation such as == can easily be defined for intervals\n\nIf the intervals are disjoints (X ∩ Y === ∅), then X == Y is [false].\nIf the intervals both contain a single floating point number, and that element is the same for both, X == Y is [true].\nOtherwise, we can not conclude anything, and X == Y must be [false, true].\n\nNot that we use intervals for all outputs, because, according to our definition, the true result must be contained in the returned interval. However, this is not convenient, as any if statement would error when used with an interval. Instead, we have opted to return respectively false and true for cases 1 and 2, and to immediately error otherwise.\n\nIn this way, we can return a more informative error, but we only error when the result is ambiguous.\n\nThis has a clear cost, however, in that some expected behaviors do not hold. For example, an Interval is not equal to itself.\n\njulia> X = interval(1, 2)\n[1.0, 2.0]_com\n\njulia> X == X\nERROR: InconclusiveBooleanOperation: `==` is purposely not supported when the intervals are overlapping. See instead `isequal_interval`\nStacktrace:\n [1] ==(x::Interval{Float64}, y::Interval{Float64})","category":"section"},{"location":"philosophy/#Intervals-as-sets","page":"Philosophy","title":"Intervals as sets","text":"We have taken the perspective to always let Intervals act as if they were numbers.\n\nBut they are also sets of numbers, and it would be nice to use all set operations defined in julia on them.\n\nHowever, Real are also sets. For example, the following is valid\n\njulia> 3 in 3\ntrue\n\nThen what should 3 in interval(2, 6) do?\n\nFor interval as a set, it is clearly true. But for intervals as a subtype of Real this is equivalent to\n\n3 == interval(2, 6)\n\nwhich must either be false (they are not the same things), or error as the result can not be established.\n\nTo be safe, we decided to go one step further and disable all set operations from julia Base on intervals. These operations can instead be performed with the specific *_interval function, for example in_interval as a replacement for in.\n\nsetdiff is an exception, as we can not meaningfully define the set difference of two intervals, because our intervals are always closed, while the result of setdiff can be open.","category":"section"},{"location":"philosophy/#hash","page":"Philosophy","title":"hash","text":"The function hash is the only case where we do not define the value of a function based on its interval extension.\n\nhash return a single hash, and not an interval bounding the image of the function.\n\njulia> hash(interval(1, 2))\n0xda823f68b9653b1a\n\njulia> hash(1.2) in hash(interval(-10, 10))\nfalse\n\nThis is justified as hash is not a mathematical function, and julia requires that hash returns a UInt.","category":"section"},{"location":"philosophy/#Summary","page":"Philosophy","title":"Summary","text":" Functions Behavior Note\nArithmetic operations +, -, *, /, ^ Interval extension Produce the NG flag when mixed with non-interval\nOther numeric function sin, exp, sqrt, etc. Interval extension \nBoolean operations ==, <, <=, iszero, isnan, isinteger, isfinite Error if the result can not be guaranteed to be either true or false See isequal_interval to test equality of intervals, and isbounded to test the finiteness of the elements\nSet operations in, issubset, isdisjoint, issetequal, isempty, union, intersect Always error Use the *_interval function instead (e.g. in_interval)\nExceptions ≈, setdiff Always error No meaningful interval extension\nHash hash Hash the interval as a julia object ","category":"section"},{"location":"manual/usage/#Manipulating-intervals","page":"Usage","title":"Manipulating intervals","text":"","category":"section"},{"location":"manual/usage/#Display-modes","page":"Usage","title":"Display modes","text":"There are several useful output representations for intervals. The display is controlled globally by the setdisplay function, which has the following options:\n\ninterval output format:\n:infsup: output of the form [1.09999, 1.30001], rounded to the current number of significant figures.\n:full: output of the form Interval(1.0999999999999999, 1.3), as in the showfull function.\n:midpoint: output in the midpoint-radius form, e.g. 1.2 ± 0.100001.\nsigdigits :: Int keyword argument: number of significant digits to show in standard mode.\ndecorations :: Bool keyword argument: whether to show decorations or not.\n\nusing IntervalArithmetic\na = interval(1.1, pi) # default display\nsetdisplay(; sigdigits = 10)\na\nsetdisplay(:full)\na\nsetdisplay(:midpoint)\na\nsetdisplay(; sigdigits = 4)\na\nsetdisplay(:infsup)\na","category":"section"},{"location":"manual/usage/#Arithmetic-operations","page":"Usage","title":"Arithmetic operations","text":"Basic arithmetic operations (+, -, *, /, ^) are defined for pairs of intervals in a standard way: the result is the smallest interval containing the result of operating with each element of each interval. More precisely, for two intervals X and Y and an operation bigcirc, we define the operation on the two intervals by\n\nX bigcirc Y bydef  x bigcirc y  x in X text and  y in Y \n\nFor example,\n\nusing IntervalArithmetic\nsetdisplay(:full)\nX = interval(0, 1)\nY = interval(1, 2)\nX + Y\n\nDue to the above definition, subtraction of two intervals may give poor enclosures:\n\nX - X","category":"section"},{"location":"manual/usage/#Elementary-functions","page":"Usage","title":"Elementary functions","text":"The main elementary functions are implemented. The functions for Interval{Float64} internally use routines from the correctly-rounded CRlibm library where possible, i.e. for the following functions defined in that library:\n\nexp, expm1\nlog, log1p, log2, log10\nsin, cos, tan\nasin, acos, atan\nsinh, cosh\n\nOther functions that are implemented for Interval{Float64} internally convert to an Interval{BigFloat}, and then use routines from the MPFR library (BigFloat in Julia):\n\n^\nexp2, exp10\natan, atanh\n\nIn particular, in order to obtain correct rounding for the power function (^), intervals are converted to and from BigFloat; this implies a significant slow-down in this case.\n\nFor example,\n\nX = interval(1)\nsin(X)\ncos(cosh(X))\nsetprecision(BigFloat, 53)\nY = big(X)\nsin(Y)\ncos(cosh(Y))\nsetprecision(BigFloat, 128)\nsin(Y)","category":"section"},{"location":"manual/usage/#Comparisons","page":"Usage","title":"Comparisons","text":"If the result of a comparison can be established with guarantee, it will be return, otherwise, an error is thrown.\n\ninterval(1) < interval(2)\ninterval(1, 5) < interval(7, 9)\ninterval(1, 5) < interval(4.99, 9)\ninterval(1.23) == interval(1.23)\ninterval(1.23) == interval(4.99, 9)\ninterval(1.23) == interval(1.2, 1.3)\n\nIn particular, if ... else ... end statements used for floating-points will often break with intervals.\n\nSee Philosophy for more details and why this choice was made.","category":"section"},{"location":"manual/usage/#Set-operations","page":"Usage","title":"Set operations","text":"Set operations are all disallowed and error on intervals to avoid ambiguities. To perform set operations on intervals, use the *_interval equivalent explicitly, e.g. issubset_interval instead of issubset.\n\nissubset(interval(1, 2), interval(2))\nissubset_interval(interval(1, 2), interval(2))\nintersect(interval(1, 2), interval(2))\nintersect_interval(interval(1, 2), interval(2))\n\nSee Philosophy for more details and why this choice was made.","category":"section"},{"location":"manual/usage/#Piecewise-functions","page":"Usage","title":"Piecewise functions","text":"Since intervals don't play well with if ... else ... end statement, we provide a utility to define function by pieces:\n\nmyabs = Piecewise(\n    Domain{:open, :closed}(-Inf, 0) => x -> -x,\n    Domain{:open, :open}(0, Inf) => identity\n)\nmyabs(-1.23)\nmyabs(interval(-1, 23))\n\nThe resulting function work with both standard numbers and intervals, and deal properly with the decorations of intervals.","category":"section"},{"location":"manual/usage/#Custom-interval-bounds-type","page":"Usage","title":"Custom interval bounds type","text":"A BareInterval{T} or Interval{T} have the restriction T <: Union{Rational,AbstractFloat} which is the parametric type for the bounds of the interval. Supposing one wishes to use their own numeric type MyNumType <: Union{Rational,AbstractFloat}, they must provide their own arithmetic operations (with correct rounding!).","category":"section"},{"location":"intro/#Overview","page":"Overview","title":"Overview","text":"The basic idea in interval arithmetic is to perform computations with a whole interval of real numbers\n\na b bydef x in mathbbR a le x le b \n\nwhere a b in mathbbR cup  pm infty ; note that despite the above notation, a b does not contain infinity when a or b are infinite.\n\nWe define functions on intervals in such a way that the result of the computation is a new interval that is guaranteed to contain the true range of the function.\n\nFor instance, by monotonicity, the exponential function is given by\n\ne^a b bydef e^a e^b\n\nOn the other hand, the squaring function is non-monotone, thus it is given by the following cases\n\na b^2 bydef\nbegincases\na^2 b^2   0 le a le b \n0 max(a^2 b^2)  a le 0 le b \nb^2 a^2  a le b le 0\nendcases\n\nOf course, we must round the lower endpoint down and the upper endpoint up to get a guaranteed enclosure of the true result.\n\nIntervalArithmetic defines such behaviour for a wide set of basic functions, thereby allowing the evaluation of more complex functions such as\n\nf(x) = sin(3x^2 - 2 cos(1x))","category":"section"},{"location":"intro/#Applications","page":"Overview","title":"Applications","text":"To illustrate the use of interval arithmetic, consider the following:\n\nusing IntervalArithmetic\nf(x) = x^2 - 2\nx = interval(3, 4)\nf(x)\n\nSince f(x) does not contain 0, the true range of the function f over the interval 3 4 is guaranteed not to contain 0, and hence we obtain the following property.\n\nTheorem: f has no root in the interval 3 4.\n\nThis theorem has been obtained using floating-point computations! In fact, we can even extend this to semi-infinite intervals:\n\nf(interval(3, Inf))\n\nTherefore, we have excluded the whole unbounded set 3 infty) from possibly containing roots of f.\n\nInterval arithmetic is the foundation of more powerful and elaborate methods in the field of computer-assisted proofs (see e.g. IntervalRootFinding.jl).\n\nThe interested reader may refer to the following books:\n\nR. E. Moore, R. B. Kearfott and M. J. Cloud, Introduction to Interval Analysis, Society for Industrial and Applied Mathematics (2009)\nW. Tucker, Validated Numerics: A Short Introduction to Rigorous Computations, Princeton University Press (2010)","category":"section"},{"location":"intro/#Compliance-with-the-IEEE-standard-for-interval-arithmetic","page":"Overview","title":"Compliance with the IEEE standard for interval arithmetic","text":"IntervalArithmetic.jl complies with the specifications described in the IEEE standard for interval arithmetic. However, the reverse-mode of functions are not implemented (see Section 10.5.4).","category":"section"},{"location":"manual/construction/#Constructing-intervals","page":"Constructing intervals","title":"Constructing intervals","text":"The library provides two interval types. The first one is BareInterval, corresponding to a basic implementation of intervals, stored by their infimum and supremum. The second type is Interval and builds on top of bare intervals, with the additional fields decoration and isguaranteed. See the sections below.\n\nusing IntervalArithmetic\nsetdisplay(:full) # print the interval in full\nbareinterval(1, π) # `bareinterval(Float64, 1, π)`\ninterval(1, π) # `interval(Float64, 1, π)`, interval decorated with `com` (common)\n\nTherefore, we strongly recommend the use of Interval over BareInterval to better track the effect of functions according to the IEEE Standard 1788-2015 specifications. For instance, taking the square root of an interval discards the negative part of the interval, without any notice for bare intervals:\n\nsqrt(bareinterval(-1, 1)) # `sqrt(bareinterval(0, 1))`\nsqrt(interval(-1, 1)) # interval decorated with `trv` (trivial)","category":"section"},{"location":"manual/construction/#Decorations","page":"Constructing intervals","title":"Decorations","text":"A decoration is a label that indicates the status of a given interval. Decorated intervals provide valuable information on the result of evaluating a function on an initial interval.\n\nUpon the application of a function f on an interval x, the resulting interval f(x) has either one of the following decorations:\n\ncom (common): x is a closed, bounded, non-empty subset of the domain of f, f is continuous on the interval x, and f(x) is bounded.\ndac (defined and continuous): x is a non-empty subset of the domain of f, and f is continuous on x.\ndef (defined): x is a non-empty subset of the domain of f; in other words, f is defined at each point of x.\ntrv (trivial): f(x) carries no meaningful information.\nill (ill-formed): f(x) is Not an Interval (NaI).\n\nEach decoration is paired with an integer as follows: ill = 0, trv = 1, def = 2, dac = 3 and com = 4. Then, decorations degrade according to the propagation order com > dac > def > trv > ill.\n\nOne can specify a decoration when constructing intervals. Otherwise, the interval is initialised with a decoration according to the underlying bare interval:\n\ncom: non-empty and bounded.\ndac: unbounded.\ntrv: empty.\nill: NaI.","category":"section"},{"location":"manual/construction/#Examples","page":"Constructing intervals","title":"Examples","text":"","category":"section"},{"location":"manual/construction/#Common","page":"Constructing intervals","title":"Common","text":"x = interval(0.5, 3)\nsqrt(x)\n\nBoth input x and output sqrt(x) are common intervals since they are closed, bounded, non-empty and the square root is continuous over 12 3.\n\nObserve that these decorations, together with the fact that any element of the interval sqrt(x) is also in the interval x, imply that the Schauder Fixed-Point Theorem is satisfied. More precisely, this computation proves the existence of a fixed-point of the square root in 12 3 (in this simple example, sqrt(1) = 1).","category":"section"},{"location":"manual/construction/#Defined-and-continuous","page":"Constructing intervals","title":"Defined and continuous","text":"x = interval(3, Inf)\nsqrt(x)\n\nBoth the intervals are unbounded, hence the maximum possible decoration is dac.\n\nNote that overflows can also produce the decoration dac:\n\nx = interval(floatmax(Float64))\nx + interval(1)","category":"section"},{"location":"manual/construction/#Defined-and-continuous-2","page":"Constructing intervals","title":"Defined and continuous","text":"x = interval(-3, 4)\nsign(x)\n\nThe sign function is discontinuous at 0, but is defined everywhere on the input interval, so the decoration of the result is def.","category":"section"},{"location":"manual/construction/#Trivial","page":"Constructing intervals","title":"Trivial","text":"x = interval(-3.5, 4)\nsqrt(x)\n\nThe negative part of x is discarded before evaluating the square root since its domain is 0 infty). The process of discarding parts of an interval that are not in the domain of a function is called loose evaluation. This event has been recorded by degrading the decoration of the resulting interval to trv, indicating that nothing is known about the relationship between x and sqrt(x).\n\nIn this case, we know why the decoration was reduced to trv. Generally, if this were just a single step in a longer calculation, a resulting decoration trv shows only that something like this occured at some step.\n\nFor instance,\n\nf = asin ∘ sqrt\nx = interval(-3, 3)\nf(x)\ny = interval(0, 3)\nf(y)\n\nIn both cases, asin(sqrt(X)) gives a result with the decoration trv; to find out where things went wrong, the function must be analyzed.\n\nsqrt(x) # `f(x)` has the decoration is `trv` since `x` contains negative values\nsqrt(y) # the decoration is `com`\nasin(sqrt(y)) # `f(x)` has the decoration is `trv` since `sqrt(y)` contains values stricly greater than `1`\n\nThis shows that loose evaluation occurred in different parts of f for x and y.\n\ndanger: Danger\nThe decoration trv is an indicator of information loss. Often this also reveals that something unexpected occured. Therefore, any interval marked by this decoration may not be trusted and the code may need to be revised.","category":"section"},{"location":"manual/construction/#Ill-formed","page":"Constructing intervals","title":"Ill-formed","text":"interval(2, 1)\ninterval(NaN)\n\nThese are all examples of ill-formed intervals, also known as NaI, resulting in the decoration ill.\n\nSimilarly to the floating point NaN, all boolean operations on an ill-formed interval return false.\n\ndanger: Danger\nThe decoration ill is an indicator that an error has occured. Therefore, when an ill-formed interval is created, a warning is raised. Any interval marked by this decoration cannot be trusted and the code needs to be debugged.","category":"section"},{"location":"manual/construction/#More-constructors","page":"Constructing intervals","title":"More constructors","text":"The submodule IntervalArithmetic.Symbols exports the infix operator .. and ± as an alias for interval; this submodule must be explicitly imported.\n\nusing IntervalArithmetic.Symbols\n0.1 .. 0.2 # interval(0.1, 0.2; format = :infsup)\n0.1 ± 0.2 # interval(0.1, 0.2; format = :midpoint)\n\nMoreover, one can parse strings into intervals. The various string formats are the following:\n\n\"[m]\" is equivalent to interval(m, m).\n\"[l, r]\" is equivalent to interval(l, r).\n\"m?r\" is equivalent to interval(m-r, m+r).\n\"m?ren\" is equivalent to interval((m-r)*1en, (m+r)*1en).\n\"m?rd\" is equivalent to interval(m-r, m).\n\"m?ru\" is equivalent to interval(m, m+r).\n\"m?\" is equivalent to interval(m + 5 precision units, m - 5 precision units).\n\"m??\" is equivalent to interval(-Inf, +Inf).\n\"m??d\" is equivalent to interval(-Inf, m).\n\"m??u\" is equivalent to interval(m, +Inf).\n\"[Entire]\", \"[entire]\" and \"[,]\" are equivalent to entireinterval().\n\"[Empty]\", \"[empty]\" and \"[]\" are equivalent to emptyinterval().\n\"[nai]\" and any other unsupported string formats are equivalent to nai().\n\nTo add a specific decoration, add \"_com\", \"_dac\", \"_dec\", \"_trv\" and \"_ill\" at the end of the string.\n\ndanger: Danger\nMost real numbers cannot be exactly represented by floating-points. In such cases, the literal expression is rounded at parse time. To construct an interval enclosing the true real number, one must rely on the string constructor mentioned above.For instance, considerx = 0.1This appears to store the real number 110  in a variable x of type Float64. Yet,x > 1//10Hence, the floating-point 0.1 is (slightly) greater than the real number 110 since 110 cannot be represented exactly in binary floating-point arithmetic, at any precision. The true value must be approximated by a floating-point number with fixed precision – this procedure is called rounding.In particular, this implies that interval(0.1) does not contain the real number 110. A valid interval containing the real number 110 can be constructed byI\"0.1\"","category":"section"},{"location":"manual/configuration/#Configuration-options","page":"Configuration","title":"Configuration options","text":"The IntervalArithmetic.jl package provides a configure function that allows users to fine-tune certain aspects of the package’s behavior. This is particularly useful for controlling trade-offs between computational speed and rigor.\n\nwarning: Warning\nThe configure function redines methods that alter the internal behavior of IntervalArithmetic. This persists across the current Julia session and affect all subsequent interval arithmetic computations.\n\nEach keyword argument sets a specific configuration option:\n\nnumtype: control the default numerical type used to represent the bounds of the intervals.\nflavor: control the flavor type of the intervals.\nrounding: control the rounding type.\npower: control the implementation used for the interval power operation, that is, the computation of x^n where x is an interval and n is a number. The choice of power implementation has implications for both performance and accuracy.\nmatmul: control the matrix multiplication algorithm.\n\nusing IntervalArithmetic\nx = interval(π)\nconfigure(; pow = :fast)\nradius(x^2)\nconfigure(pow = :slow)\nradius(x^2)","category":"section"},{"location":"manual/symbols/#The-submodule-Symbols","page":"Symbols","title":"The submodule Symbols","text":"IntervalArithmetic includes the submodule Symbols to make coding a bit simpler with respect to the use of some functions of the library. Some examples are provided here.\n\nusing IntervalArithmetic, IntervalArithmetic.Symbols\na = 0 .. 2\nb = 1 ± 0.5\na ≛ a\nb ⊑ a\nb ⋤ a\n∅ ⪽ ℝ\n\nThe following table summarizes the functions, the usage with the corresponding (unicode) symbols, how to obtain the symbol in Julia, and a brief description of the function.\n\nFunction Symbol Julia syntax Description\ninterval(a, b; format=:infsup) ..(a,b)  Create interval [a, b] using bounds\ninterval(m, r; format=:midpoint) ±(m, r) \\pm<tab> Create interval [m - r, m + r] using midpoint-radius form\nisequal_interval(x, y) ≛(x, y) \\starequal<tab> Check interval equality\nissubset_interval(x, y) ⊑(x, y) \\sqsubseteq<tab> Check if x is a (non-strict) subset of y\nisstrictsubset(x, y) ⋤(x, y) \\sqsubsetneq<tab> Check if x is a strict subset of y\nisinterior(x, y) ⪽(x, y) \\subsetdot<tab> Check if x is in the interior of y\nprecedes(x, y) ⪯(x, y) \\preceq<tab> Precedes relation\nstrictprecedes(x, y) ≺(x, y) \\prec<tab> Strictly precedes relation\nhull(x, y) ⊔(x, y) \\sqcup<tab> Interval hull of x and y\nintersect_interval(x, y) ⊓(x, y) \\sqcap<tab> Intersection of intervals\nemptyinterval() ∅ \\emptyset<tab> Empty interval\nentireinterval() ℝ \\bbR<tab> Entire real line","category":"section"},{"location":"#IntervalArithmetic.jl","page":"Home","title":"IntervalArithmetic.jl","text":"IntervalArithmetic.jl is a Julia package for validated numerics in Julia. All calculations are carried out using interval arithmetic where quantities are treated as intervals. The final result is a rigorous enclosure of the true value.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg # Julia v1.10 or above\nredirect_stderr(devnull) do # hide\nPkg.add(\"IntervalArithmetic\")\nend # hide","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use the IntervalArithmetic library in your publication, research, teaching, or other activities, please use the BibTeX template CITATION.bib.","category":"section"}]
}
